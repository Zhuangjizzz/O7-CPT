# 17 Nyquist-Rate A/D Converters

Architectures for realizing analog-to-digital (A/D) converters can be roughly divided into three categories (Table 17.1)-low-to-medium speed, medium speed, and high speed. In this chapter, design details are discussed for these different approaches except for oversampling converters. Oversampling converters are best described using many signal processing concepts and are therefore discussed separately in Chapter 18.

Before proceeding, it should be noted that when discussing the design of A/D converters, we usually ignore the 0.5 LSB offset present in the A/D transfer characteristic. Such a simplification is made so as not to complicate the concepts presented. Many of the converter architectures described make extensive use of switched capacitor circuits and comparators; the reader is referred to those chapters for more detail on those circuits.

## 17.1 INTEGRATING CONVERTERS

Integrating A/D converters is a popular approach for realizing high-accuracy data conversion on very slowmoving signals. These types of converters have very low offset and gain errors in addition to being highly linear. A further advantage of integrating converters is the small amount of circuitry required in their implementation. One application that has traditionally made use of integrating converters is measurement instruments such as voltage or current meters.

A simplified diagram for a dual-slope integrating converter is shown in Fig. 17.1. Dual-slope refers to this converter performing its conversion in two phases, (I) and (II), in the following manner (Fig. 17.2):

Phase (I) Phase (I) is a fixed time interval of length $\mathrm{T}_{1}$ determined by running the counter for $2^{\mathrm{N}}$ clock cycles. Thus, we have

$$
\begin{equation*}
\mathrm{T}_{1}=2^{\mathrm{N}} \mathrm{~T}_{\mathrm{clk}} \tag{17.1}
\end{equation*}
$$

where $T_{\text {clk }}$ is the period for one clock cycle. During this interval, switch $S_{1}$ is connected to $-V_{\text {in }}$ such that $V_{x}$ ramps up proportional to the magnitude of $\mathrm{V}_{\mathrm{in}}$. Assuming $\mathrm{V}_{\mathrm{x}}$ is initially equal to zero (due to a pulse on $\mathrm{S}_{2}$ ), and

Table 17.1 Different A/D converter architectures.

| Low-to-Medium Speed, <br> High Accuracy | Medium Speed, <br> Medium Accuracy | High Speed, <br> Low-to-Medium Accuracy |
| :--- | :--- | :--- |
| Integrating | Successive approximation | Flash |
| Oversampling | Algorithmic | Two-step |
|  |  | Interpolating |
|  |  | Folding |
|  |  | Pipelined |
|  |  | Time-interleaved |

that $\mathrm{V}_{\text {in }}$ is constant, we have the following relationship for $\mathrm{V}_{\mathrm{x}}$ :

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}(\mathrm{t})=-\int_{0}^{\mathrm{t}} \frac{\left(-\mathrm{V}_{\mathrm{in}}\right)}{\mathrm{R}_{1} \mathrm{C}_{1}} \mathrm{~d} \tau=\frac{\mathrm{V}_{\mathrm{in}}}{\mathrm{R}_{1} \mathrm{C}_{1}} t \tag{17.2}
\end{equation*}
$$

Thus, at the end of phase (I), the value of $V_{x}$ is equal to $V_{i n} T_{1} / R_{1} C_{1}$.
Phase (II) Phase (II) occurs for a variable amount of time, $\mathrm{T}_{2}$, as shown in Fig. 17.2 for three different input voltages. At the beginning of this phase, the counter is reset and switch $S_{1}$ is connected to $V_{\text {ref }}$, resulting in a constant slope for the decaying voltage at $\mathrm{V}_{\mathrm{x}}$. To obtain the digital output value, the counter simply counts until $\mathrm{V}_{\mathrm{x}}$ is less than zero, at which point that count value equals the digitized value of the input signal, $\mathrm{V}_{\mathrm{in}}$. Thus, assuming the digital output count is normalized so that the largest count is unity, the counter output, $\mathrm{B}_{\text {out }}$, can be defined to be

$$
\begin{equation*}
\mathrm{B}_{\text {out }}=\mathrm{b}_{1} 2^{-1}+\mathrm{b}_{2} 2^{-2}+\cdots+\mathrm{b}_{\mathrm{N}-1} 2^{-(\mathrm{N}-1)}+\mathrm{b}_{\mathrm{N}} 2^{-\mathrm{N}} \tag{17.3}
\end{equation*}
$$

![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-047.jpg?height=499&width=1243&top_left_y=819&top_left_x=276)

Fig. 17.1 Integrating (dual slope) A/D converter.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-047.jpg?height=656&width=1159&top_left_y=1439&top_left_x=320)

Fig. 17.2 Operation of the integrating converter for three different input voltages.
and we have

$$
\begin{equation*}
T_{2}=2^{N} B_{\text {out }} T_{c l k}=\left(b_{1} 2^{N-1}+b_{2} 2^{N-2}+\cdots+b_{N-1} 2+b_{N}\right) T_{c l k} \tag{17.4}
\end{equation*}
$$

To see why this count gives the correct value, we find the equation for $\mathrm{V}_{\mathrm{x}}$ during phase (II) to be given by

$$
\begin{align*}
V_{x}(t) & =-\int_{T_{1}}^{t} \frac{V_{\text {ref }}}{R_{1} C_{1}} d \tau+V_{x}\left(T_{1}\right) \\
& =\frac{-V_{\text {ref }}}{R_{1} C_{1}}\left(t-T_{1}\right)+\frac{V_{\text {in }} T_{1}}{R_{1} C_{1}} \tag{17.5}
\end{align*}
$$

Since $V_{x}$ equals zero when $t=T_{1}+T_{2}$, we can write

$$
\begin{equation*}
0=\frac{-\mathrm{V}_{\mathrm{ref}} \mathrm{~T}_{2}}{\mathrm{R}_{1} \mathrm{C}_{1}}+\frac{\mathrm{V}_{\mathrm{in}} \mathrm{~T}_{1}}{\mathrm{R}_{1} \mathrm{C}_{1}} \tag{17.6}
\end{equation*}
$$

and thus $T_{2}$ is related to $T_{1}$ by the following relationship:

$$
\begin{equation*}
\mathrm{T}_{2}=\mathrm{T}_{1}\left(\frac{\mathrm{~V}_{\mathrm{in}}}{\mathrm{~V}_{\mathrm{ret}}}\right) \tag{17.7}
\end{equation*}
$$

Combining (17.7) with (17.1) and (17.4), we find

$$
\begin{equation*}
B_{\text {out }}=b_{1} 2^{-1}+b_{2} 2^{-2}+\cdots+b_{N-1} 2^{-(N-1)}+b_{N} 2^{-N}=\frac{V_{\text {in }}}{V_{\text {ref }}} \tag{17.8}
\end{equation*}
$$

as expected.

Key Point: Dual-slope integrating conversion proceeds first by integrating the input for a fixed time period, then applying a known input to the integrator and measuring the time required for the integrator output to return to zero.

From (17.8), we see that in a dual-slope conversion (i.e., two phases), the digital output does not depend on the time constant, $\mathrm{R}_{1} \mathrm{C}_{1}$. In fact, the value of this time constant need only be stable during a single conversion for proper operation. However, $\mathrm{R}_{1}$ and $\mathrm{C}_{1}$ should be chosen such that a reasonable large peak value of $\mathrm{V}_{\mathrm{x}}$ is obtained without clipping to reduce noise effects. It is also possible to perform a single-slope conversion where only one integration phase is needed, however the integration time would then be a function of the time-constant value, $\mathrm{R}_{1} \mathrm{C}_{1}$, and a gain error would most likely occur.

Although a dual-slope converter does not suffer from gain error, it can have an offset error due to opamp offset and other factors. Such an offset error can be calibrated out by going to a quad-slope conversion. In a quad-slope conversion, a dual-slope conversion is performed twice: once with the input connected to ground (or other known dc quantity), and then with the input connected to the signal to be converted, $\mathrm{V}_{\mathrm{in}}$. A subtraction of the two output words causes the offset error to be reduced to zero.

Key Point: Dual-slope conversion does not require accuracy in defining the integration time constant. Offset errors can be calibrated by performing an additional conversion using a known dc input quantity.

The conversion speed for these types of converters is quite slow. For example, in a dual-slope converter, the worst-case conversion speed occurs when $\mathrm{V}_{\text {in }}$ equals $\mathrm{V}_{\text {ref }}$. In this case, the number of clock cycles to perform a conversion is $2^{\mathrm{N}+1}$. Thus for a 16 -bit converter with a clock frequency equal to 1 MHz , the worst-case conversion rate is around 7.6 Hz .

Finally, it should be mentioned that by a careful choice for $T_{1}$, certain frequency components superimposed on the input signal can be significantly attenuated. Note that this converter effectively "integrates and dumps" the input signal. If we relax the assumption that $\mathrm{V}_{\text {in }}$ is constant in (17.2), we see that before being converted $\mathrm{V}_{\text {in }}$ is actually integrated over a time window $T_{1}$ in duration,

$$
\begin{equation*}
\int_{0}^{T_{1}} \frac{V_{\text {in }}(\tau)}{R_{1} C_{1}} d \tau \tag{17.9}
\end{equation*}
$$

which is equivalent to convolution by a rectangular time function. Since the Fourier transform of a rectangular pulse is a " $\sin (\mathrm{x}) / x$ " type response, we have an effective input filter with a transfer function,

$$
\begin{equation*}
|H(f)|=\left|\frac{\sin \left(\pi \mathrm{fT}_{1}\right)}{\left(\pi \mathrm{fT} \mathrm{~T}_{1}\right)}\right| \tag{17.10}
\end{equation*}
$$

Therefore, integrating converters have a low-pass response, with nulls at all integer multiples of $f=1 / T_{1}$.

Key Point: Integrating converters inherently filter the input with a $\sin x / x$ frequency response.

#### EXAMPLE 17.1

If the input signal, $\mathrm{V}_{\mathrm{in}}$, is a dc level with power line noise of 60 Hz superimposed on it, choose $\mathrm{T}_{1}$ to filter out the power line noise.

#### Solution

Write $\mathrm{V}_{\text {in }}$ as

$$
\begin{equation*}
V_{\text {in }}=V_{\text {in(ideal) }}+V_{\text {in(60 Hz) }} \tag{17.11}
\end{equation*}
$$

where $\mathrm{V}_{\text {in(ideal) }}$ is the desired dc signal level and $\mathrm{V}_{\mathrm{in}(60 \mathrm{~Hz})}$ is the interfering 60 Hz noise; or mathematically,

$$
\begin{equation*}
V_{i n(60 H z)}=A \sin (120 \pi t+\phi) \tag{17.12}
\end{equation*}
$$

where A and $\phi$ are arbitrary magnitude and phase values. Now substituting this relationship for $\mathrm{V}_{\text {in }}$ into (17.2), we have

$$
\begin{equation*}
V_{x}\left(T_{1}\right)=-\int_{0}^{T_{1}} \frac{\left(-V_{\text {in }}\right)}{R_{1} C_{1}} d \tau=-\int_{0}^{T_{1}} \frac{\left(-V_{\text {in (ideal })}\right)}{R_{1} C_{1}} d \tau-\int_{0}^{T_{1}} \frac{\left(-V_{\text {in }(60 H z)}\right)}{R_{1} C_{1}} d \tau \tag{17.13}
\end{equation*}
$$

However, the last term in (17.13) can be shown to equal zero when $T_{1}$ is an integer multiple of $1 /(60 \mathrm{~Hz})$ (i.e., 16.67 ms ). In this way, the peak value, $\mathrm{V}_{\mathrm{x}}\left(\mathrm{T}_{1}\right)$, remains correct so that the conversion is performed without error. Note that for this same value of $\mathrm{T}_{1}$, the harmonics of 60 Hz are also suppressed (i.e., $120 \mathrm{~Hz}, 180 \mathrm{~Hz}, 240$ Hz , etc.). The converter's frequency response is shown in Fig. 17.3 with $T_{1}=1 /(60 \mathrm{~Hz})$. Note that full suppression is achieved at harmonics of 60 Hz , as expected.

In fact, other frequencies are also attenuated but not fully suppressed as are the harmonics of $1 / T_{1}$. Note the $-20 \mathrm{~dB} /$ decade slope in Fig. 17.3, so that higher frequencies are attenuated more.

#### EXAMPLE 17.2

It is desired to build a 16 -bit two-slope integrating $A / D$ such that a maximum input signal of $\mathrm{V}_{\text {in }}=3 \mathrm{~V}$ results in the peak voltage of $\mathrm{V}_{\mathrm{x}}$ being 4 V . In addition, input noise signals at 50 Hz and harmonics should be significantly attenuated. Find the required RC time constant and clock rate. Also, find the attenuation of a noise signal around 1 kHz superimposed on the input signal.

#### Solution

Since 50 Hz and harmonics are to be rejected, we choose
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-050.jpg?height=647&width=1173&top_left_y=179&top_left_x=304)

Fig. 17.3 Magnitude response of the effective input filter for an integrating-type converter with $T_{1}=1 /(60 \mathrm{~Hz})$

$$
\begin{equation*}
\mathrm{T}_{1}=\frac{1}{50}=20 \mathrm{~ms} \tag{17.14}
\end{equation*}
$$

Thus, for a 16-bit converter, we require a clock frequency of

$$
\begin{equation*}
\mathrm{f}_{\mathrm{clk}}=\frac{1}{\mathrm{~T}_{\mathrm{clk}}}=\frac{2^{16}}{\mathrm{~T}_{1}}=3.28 \mathrm{MHz} \tag{17.15}
\end{equation*}
$$

To find the RC time constant needed, we note that at the end of phase (I), $\mathrm{V}_{\mathrm{x}}$ is given by

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=\frac{\mathrm{V}_{\mathrm{in}} \mathrm{~T}_{1}}{\mathrm{R}_{1} \mathrm{C}_{1}} \tag{17.16}
\end{equation*}
$$

and using the values of $\mathrm{V}_{\mathrm{x}}=4 \mathrm{~V}, \mathrm{~V}_{\mathrm{in}}=3 \mathrm{~V}$, and $\mathrm{T}_{1}=20 \mathrm{~ms}$ results in

$$
\begin{equation*}
\mathrm{R}_{1} \mathrm{C}_{1}=15 \mathrm{~ms} \tag{17.17}
\end{equation*}
$$

Finally, the attenuation of a $1-\mathrm{kHz}$ signal is infinite since it is a harmonic of 50 kHz . However, as seen in (17.10), attenuation is reduced halfway between harmonics, so we find the gain for an input signal at 975 Hz to be

$$
\begin{equation*}
|\mathrm{H}(\mathrm{f})|=\left|\frac{\sin (\pi \times 975 \mathrm{~Hz} \times 20 \mathrm{~ms})}{\pi \times 975 \mathrm{~Hz} \times 20 \mathrm{~ms}}\right|=16.3 \times 10^{-3} \tag{17.18}
\end{equation*}
$$

which implies the attenuation is 36 dB .

## 17.2 SUCCESSIVE-APPROXIMATION CONVERTERS

Successive-approximation A/D converters are one of the most popular approaches for realizing A/D converters due to their amazing versatility. They can provide reasonably quick conversion time, or they can be used for
relatively high accuracy, and can operate with very low power in either case. Fundamentally, these benefits arise because successive-approximation converters require only modest circuit complexity, in the simplest cases requiring only a single comparator, a bank of capacitors with switches, and a small amount of digital control logic.

To understand the basic operation of successive-approximation converters, knowledge of the search algorithm referred to as a "binary search" is helpful. As an example of a binary search, consider the game of guessing a random number from 1 to 128 where one can ask only questions that have a "yes/no" response. The first question might be, "Is the number greater than 64 ?" If the answer is yes, then the second question asks whether the number is greater than 96 . However, if the first answer is no, then the second question asks whether the number is greater than 32. The third question divides the search space in two once again and the process is repeated until the random number is determined. In general, a binary search divides the search space in two each time, and the desired data can be found in N steps for a set of organized data of size $2^{\mathrm{N}}$.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-051.jpg?height=1327&width=956&top_left_y=736&top_left_x=442)

Fig. 17.4 Flow graph for the successive-approximation approach.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-052.jpg?height=379&width=1213&top_left_y=169&top_left_x=300)

Fig. 17.5 D/A converter-based successive-approximation converter.

Key Point: Successive-approximation $A / D$ converters are very versatile, capable of moderately high speed or accuracy with relatively low power. They are relatively simple circuits, in the simplest cases requiring only a single comparator, a bank of capacitors and switches, and a small digital logic circuit. Their biggest drawback is that they operate iteratively and therefore require many clock cycles to perform a single conversion.

Successive-approximation converters apply a binary search algorithm to determine the closest digital word to match an input signal. Specifically, in the first period, after possibly the reset period, the MSB, $b_{1}$, is determined. In the second period, the next bit, $b_{2}$, is determined, followed by $b_{3}$ and so on until all $N$ bits are determined. Thus, in its most straightforward implementation, a successive-approximation converter requires N clock cycles to complete an N -bit conversion. A flow graph for a signed conversion using a successive-approximation approach is shown in Fig. 17.4. Here, the signed output is in offset-binary coding and the input signal is assumed to be within $\pm 0.5 \mathrm{~V}_{\text {ret }}$. The flow graph for a unipolar conversion is only slightly different and is left as an exercise for the reader. The major drawback of successive-approximation converters is that, because their principle of operation is an iterative search, they require multiple clock cycles for each input conversion. This limits their conversion frequency to far below the circuit's maximum clock frequency, particularly when high resolution is sought since more iterations are required.

### 17.2.1 D/A-Based Successive Approximation

The block diagram for a unipolar successive-approximation A/D converter that uses a D/A converter is shown in Fig. 17.5. The successive-approximation register (SAR) and control logic are entirely digital and perform the necessary binary search. At the end of the conversion, the digital value in the SAR results in the voltage $\mathrm{V}_{\mathrm{D} / \mathrm{A}}$ being within $0.5 \mathrm{~V}_{\mathrm{LSB}}$ of the input signal. With this type of architecture, the $\mathrm{D} / \mathrm{A}$ converter typically determines the accuracy and speed of the $\mathrm{A} / \mathrm{D}$ converter. Note that a sample and hold is required at the input so that the value to be converted does not change during the conversion time.

#### EXAMPLE 17.3

Consider the case where $\mathrm{V}_{\text {ret }}=1 \mathrm{~V}, \mathrm{~V}_{\text {in }}=0.354 \mathrm{~V}$, and a 3-bit conversion is performed. Find intermediate $\mathrm{D} / \mathrm{A}$ values and the final output.

#### Solution

In this case, $\mathrm{V}_{\mathrm{LSB}}=0.125 \mathrm{~V}$.

In cycle $1: B_{\text {out }}=100$ so that $V_{D / A}=0.5 \mathrm{~V}$. Since $V_{\text {in }}<V_{D / A}, b_{1}$ is set to 0 .
In cycle 2: $B_{\text {out }}=010$ so that $V_{D / A}=0.25 \mathrm{~V}$. Since $V_{\text {in }}>V_{D / A}, b_{2}$ is set to 1.
In cycle 3 : $B_{\text {out }}=011$ so that $V_{D / A}=0.375 \mathrm{~V}$. Since $V_{\text {in }}<V_{D / A}, b_{3}$ is set to 0 .
Therefore, the resulting output is the last value of $B_{\text {out }}$, which is 010 . Although the final quantization error is $0.831 \mathrm{~V}_{\text {LSB }}$, it is greater than $\pm 0.5 \mathrm{~V}_{\mathrm{LSB}}$ because we have not accounted for the 0.5 LSB offset as discussed at the beginning of this chapter.

### 17.2.2 Charge-Redistribution A/D

The straightforward approach of using a separate $\mathrm{D} / \mathrm{A}$ converter and setting it equal to the input voltage (within one LSB) can be modified to the flow graph shown in Fig. 17.6. Here, the error signal V equals the difference between the input signal, $\mathrm{V}_{\mathrm{in}}$, and the $\mathrm{D} / \mathrm{A}$ output, $\mathrm{V}_{\mathrm{D} / \mathrm{A}}$. As a result, V is always compared to ground, as seen at the top of the flow graph, and the goal is to set this error difference within one LSB of zero.

One of the first switched-capacitor analog systems using this approach is a charge-redistribution MOS A/D converter [McCreary, 1975]. With such a converter, the sample and hold, D/A converter, and the difference portion of the comparator are all combined into a single circuit. The unipolar case is shown in Fig. 17.7 and operates as follows:

1. Sample mode: In the first step, all the capacitors are charged to $\mathrm{V}_{\text {in }}$ while the comparator is being reset to its threshold voltage through $\mathbf{S}_{2}$, In this step, note that the capacitor array is performing the sample-andhold operation.
2. Hold mode: Next, the comparator is taken out of reset by opening $\mathbf{s}_{2}$, and then all the capacitors are switched to ground. This causes $\mathrm{V}_{\mathrm{x}}$, which was originally zero, to change to $-\mathrm{V}_{\mathrm{in}}$, thereby holding the input signal, $\mathrm{V}_{\mathrm{in}}$, on the capacitor array. (This step is sometimes merged with the first bit time during bit cycling.) Finally, $s_{1}$ is switched so that $\mathrm{V}_{\text {ref }}$ can be applied to the capacitor array during bit cycling.
3. Bit cycling: Next, the largest capacitor (i.e., the 16 C capacitor in this example) is switched to $\mathrm{V}_{\text {ref }} . \mathrm{V}_{\mathrm{x}}$ now goes to $\left(-\mathrm{V}_{\text {in }}+\mathrm{V}_{\text {ref }} / 2\right)$. If $\mathrm{V}_{\mathrm{x}}$ is negative, then $\mathrm{V}_{\text {in }}$ is greater than $\mathrm{V}_{\text {ref }} / 2$, and the MSB capacitor is left connected to $V_{\text {ref }}$. Also $b_{1}$ is considered to be a 1 . Otherwise, the MSB capacitor is reconnected to ground and $b_{1}$ is taken to be 0 . This process is repeated $N$ times, with a smaller capacitor being switched each time, until the conversion is finished.

To get an exact division by two, note that an additional unit capacitor of size C has been added so that the total capacitance is $2^{\mathrm{N}} \mathrm{C}$ rather than $\left(2^{\mathrm{N}}-1\right) \mathrm{C}$. Also, the capacitor bottom plates should be connected to the $\mathrm{V}_{\text {ref }}$ side, not to the comparator side, to minimize the parasitic capacitance at node $\mathrm{V}_{\mathrm{x}}$. Although parasitic capacitance at $\mathrm{V}_{\mathrm{x}}$ does not cause any conversion errors with an ideal comparator, it does attenuate the voltage $\mathrm{V}_{\mathrm{x}}$.

A signed $A / D$ conversion can be realized by adding a $-\mathrm{V}_{\text {ref }}$ input. If $\mathrm{V}_{\mathrm{x}}$ is less than zero at the first step, then proceed as in the unipolar case using $\mathrm{V}_{\text {ref }}$. Otherwise, if $\mathrm{V}_{\mathrm{x}}$ is greater than zero, use $-\mathrm{V}_{\text {ref }}$ and test for $\mathrm{V}_{\mathrm{x}}$ greater than zero when deciding whether to leave the capacitors connected to $-V_{\text {ret }}$ or not

Key Point: The accuracy of successive-approximation converters is often determined by that of the D/A converter. In the case of charge-redistribution converters, this role is played by a bank of comparators whose matching is important.
at each bit cycling.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-054.jpg?height=1257&width=928&top_left_y=180&top_left_x=426)

Fig. 17.6 Flow graph for a modified successive approximation (divided remainder).

#### EXAMPLE 17.4

Find intermediate node voltages at $\mathrm{V}_{\mathrm{x}}$ during the operation of the 5 -bit charge-redistribution converter shown in Fig. 17.7 when $\bigvee_{\text {in }}=1.23 \mathrm{~V}$ and $\bigvee_{\text {ref }}=5 \mathrm{~V}$. Assume a parasitic capacitance of 8 C exists on the node at $\bigvee_{\mathrm{x}}$.

#### Solution

First, $\mathrm{V}_{\mathrm{x}}=0$ during sample mode. Next, during hold mode, all capacitors are switched and the charge on $\mathrm{V}_{\mathrm{x}}$ is shared between the 32 C total converter capacitance and the parasitic 8 C capacitance, resulting in

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=\frac{32}{32+8} \times-\mathrm{V}_{\mathrm{in}}=-0.984 \mathrm{~V} \tag{17.19}
\end{equation*}
$$

![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-055.jpg?height=1766&width=1334&top_left_y=179&top_left_x=210)

Fig. 17.7 A 5-bit unipolar charge-redistribution A/D converter.

During the first bit cycling, $b_{1}$ is switched, resulting in

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=-0.984+\frac{16}{40} \times 5 \mathrm{~V}=1.016 \mathrm{~V} \tag{17.20}
\end{equation*}
$$

Since this result is greater than zero, switch $b_{1}$ is reversed back to ground and $\mathrm{V}_{\mathrm{x}}$ returns to -0.984 V . Thus, $b_{1}=0$.

Next, $b_{2}$ is switched, and we have

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=-0.984+\frac{8}{40} \times 5 \mathrm{~V}=0.016 \mathrm{~V} \tag{17.21}
\end{equation*}
$$

It is also greater than zero, so $\mathrm{b}_{2}=0$, and $\mathrm{V}_{\mathrm{x}}$ is set back to -0.984 V by switching $\mathrm{b}_{2}$ back to ground.
When $b_{3}$ is next switched, we have

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=-0.984+\frac{4}{40} \times 5=-0.484 \mathrm{~V} \tag{17.22}
\end{equation*}
$$

Since this result is less than zero, $b_{3}=1$, and switch $b_{3}$ is left connected to $V_{\text {ref }}$.
Next, $\mathrm{b}_{4}$ is switched, resulting in

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=-0.484+\frac{2}{40} \times 5=-0.234 \mathrm{~V} \tag{17.23}
\end{equation*}
$$

which is also less than zero, so $b_{4}=1$, and this switch is left connected to $V_{\text {ref }}$.
Finally, $\mathrm{b}_{5}$ is switched, resulting in

$$
\begin{equation*}
\mathrm{V}_{\mathrm{x}}=-0.234+\frac{1}{40} \times 5=-0.109 \mathrm{~V} \tag{17.24}
\end{equation*}
$$

which is also less than zero, so $b_{5}=1$.
Therefore, the output is given by $B_{\text {out }}=00111$ and voltage $V_{x}$ is within a $V_{\text {LSB }}$ of ground $\left(\mathrm{V}_{\text {LSB }}=5 / 32 \mathrm{~V}\right)$.

The same structure as the unipolar case can be used to realize a signed $\mathrm{A} / \mathrm{D}$ conversion while using only a single $\mathrm{V}_{\text {ref }}$ if a slightly modified switching arrangement is used. Referring to Fig. 17.8, and assuming $\mathrm{V}_{\text {in }}$ is between $\pm \mathrm{V}_{\text {ref }} / 2$, the conversion proceeds as follows:

1. Sample mode: In the first step, all the capacitors, except for the largest capacitor, are charged to $\mathrm{V}_{\mathrm{in}}$ while the comparator is being reset to its threshold voltage. For the signed case, the largest capacitor is now connected to $\mathrm{V}_{\text {ref }} / 2$.
2. Hold mode: Next, the comparator is first taken out of reset, and then all the capacitors, except the largest one, are switched to ground. This causes $\mathrm{V}_{\mathrm{x}}$, which was originally zero, to change to $-\mathrm{V}_{\mathrm{in}} / 2$. At the end of this step, the sign of the input signal is determined by looking at the comparator output.
3. Bit cycling: Next, the largest capacitor (i.e., the 16 C capacitor in this example) is switched to ground if, and only if, $\mathrm{V}_{\mathrm{x}}$ is larger than zero (i.e., when $\mathrm{V}_{\text {in }}$ is less than zero). Specifically, if $\mathrm{V}_{\mathrm{x}}$ is less than zero, then $\mathrm{V}_{\mathrm{in}}$ is positive and $\mathrm{b}_{1}$ is set to 1 , and conversion proceeds as in the unipolar case, starting with $b_{2}$, until conversion is completed. However, if $V_{x}$ is larger than zero, $b_{1}$ is set to 0 , the largest capacitor is switched to ground, causing $\mathrm{V}_{\mathrm{x}}$ to become $-\mathrm{V}_{\text {in }} / 2-\mathrm{V}_{\text {ref }} / 4$ (which is a negative value), and conversion proceeds as in the unipolar case, starting with $\mathrm{b}_{2}$. Once conversion is completed, some digital recoding may be required to obtain the desired output code.
This approach for realizing signed $A / D s$ has the disadvantage that $V_{\text {in }}$ has been attenuated by a factor of two, which makes noise more of a problem for high-resolution A/Ds. Also, any error in the MSB capacitor now causes both an offset and a sign-dependent gain error. The latter causes integral nonlinearity errors.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-057.jpg?height=1769&width=1346&top_left_y=177&top_left_x=230)

Fig. 17.8 A 5-bit signed charge-redistribution A/D converter.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-058.jpg?height=1042&width=1454&top_left_y=189&top_left_x=168)

Fig. 17.9 Resistor-capacitor hybrid A/D converter.

### 17.2.3 Resistor-Capacitor Hybrid

A combination of the resistor-string and capacitor-array approaches in a hybrid A/D converter, similar to the hybrid D/A converter [Fotouhi, 1979], is shown in Fig. 17.9.

The first step is to charge all the capacitors to $\mathrm{V}_{\text {in }}$ while the comparator is being reset. Next, a successiveapproximation conversion is performed to find the two adjacent resistor nodes that have voltages larger and smaller than $\mathrm{V}_{\mathrm{in}}$. One bus will be connected to one node while the other is connected to the other node. All of the capacitors are connected to the bus having the lower voltage. A successive approximation using the capacitor-array network is then done. Starting with the largest capacitor, a capacitor is switched to the adjacent resistor-string node having a larger voltage. If the comparator output is a 1 , it is switched back and $b_{i}$ is a 0 . Otherwise, the switch is left as is and $b_{i}$ is a 1 . Since the resistor string is monotonic, this type of converter is guaranteed monotonic if the capacitor array is monotonic.

### 17.2.4 Speed Estimate for Charge-Redistribution Converters

The major limitation on speed with charge redistribution converters is often due to the RC time constants of the capacitor array and switches. To estimate this time, consider the simplified model of a capacitor array being reset,
as shown in Fig. 17.10. Here, $R, R_{s 1}$, and $R_{s 2}$ represent the switch-on resistances of the bit line, $s 1$ and $s 2$ switches, respectively. Although this circuit is easily simulated using SPICE to find its settling time, it is useful to have a rough estimate of the charging time to speed up the design process. As in Section 16.1, the zero-value timeconstant approach [Sedra, 1991] can be used to obtain an estimate of the high-frequency time constant by summing individual time constants due to each capacitor. For example, the individual time constant due to the capacitance $2 C$ equals $\left(R_{s 1}+R+R_{s 2}\right) 2 C$. Following such an approach, the zero-value time constant for the circuit shown in Fig. 17.10 is equal to

$$
\begin{equation*}
\tau_{\text {eq }}=\left(R_{s 1}+R+R_{s 2}\right) 2^{N} C \tag{17.25}
\end{equation*}
$$

For better than 0.5 -LSB accuracy, we need

$$
\begin{equation*}
e^{-T / \tau_{\text {eq }}}<\frac{1}{2^{N+1}} \tag{17.26}
\end{equation*}
$$

where $T$ is the charging time. This equation can be simplified to

$$
\begin{equation*}
\mathrm{T}>\tau_{\mathrm{eq}}(\mathrm{~N}+1) \ln (2)=0.69(\mathrm{~N}+1) \tau_{\mathrm{eq}} \tag{17.27}
\end{equation*}
$$

It has been observed that (17.27) gives results about 30 percent higher than those obtained by simulating the actual RC network shown in Fig. 17.10. So while (17.27) can be used to roughly determine the maximum sampling rate, the final design should be simulated using accurate transistor models. Finally, although this result is not the same for all charge-redistribution A/D converters (for example, the size of the switches going to the larger capacitors may be increased to reduce their on resistance), the basic approach can be modified for most chargeredistribution $\mathrm{A} / \mathrm{D}$ converters.

### 17.2.5 Error Correction in Successive-Approximation Converters

With the best matching accuracy of on-chip elements being about 0.1 percent, one is limited to successiveapproximation converters having 10 -bit accuracy specifications without some sort of calibration. One errorcorrection technique that has been used to obtain 16-bit linear converters is shown in Fig. 17.11 [Lee, 1984]. In this approach, the MSB array is realized using binary-weighted capacitors that determine, for example, the first 10 bits.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-059.jpg?height=583&width=947&top_left_y=1501&top_left_x=433)

Fig. 17.10 Simplified model of a capacitor array during the sampling time.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-060.jpg?height=994&width=1389&top_left_y=183&top_left_x=196)

Fig. 17.11 A charge-redistribution A/D converter with error correction.

For a 16-bit converter, the final 6 bits are determined using an additional capacitor and a resistor string referred to as a sub-dac. Although this combination of an MSB capacitor array and an LSB resistor string is not inherently monotonic, it can be easily autocalibrated at start-up by adding a second resistor string referred to as a cal-dac.

Calibration is done by measuring the errors of each capacitor, starting with the largest capacitor, calculating the correction terms required, and then storing the correction terms in a data register as $\mathrm{DV}_{\mathrm{ei}}$. During a regular successive approximation operation, whenever a particular capacitor is used, its error is cancelled by adding the value stored in the data register to that stored in an accumulator register, which contains the sum of the correction terms for all of the other capacitors currently connected to $\mathrm{V}_{\text {ref }}$. No correction terms are measured for the resistor sub-dac; its accuracy is not critical since it only determines the remaining LSBs.

The error terms are found starting with the MSB capacitor, $\mathrm{C}_{1}$. It is connected to ground and all of the other capacitors are connected to $\mathrm{V}_{\text {ret }}$ while the comparator is reset. Next, the comparator is taken out of reset mode, all of the other capacitors are switched to ground, and $C_{1}$ is switched to $V_{\text {ref }}$. Defining $C_{\text {total }}$ to be the sum of all the capacitors in the array, the ideal value of $C_{1}$ is $C_{\text {total }} / 2$. However, in practice $C_{1}$ varies from its ideal value, and thus, $\mathrm{C}_{1}$ can be written as

$$
\begin{equation*}
\mathrm{C}_{1} \equiv\left(\mathrm{C}_{\text {total }} / 2\right)+\Delta \mathrm{C}_{1} \tag{17.28}
\end{equation*}
$$

where $\Delta \mathrm{C}_{1}$ is the capacitance error (either positive or negative). As a result, the simplified model shown in Fig. 17.12 (a) occurs after the switches are reversed. Here, the remaining capacitance equals $\left(\mathrm{C}_{\text {total }} / 2\right)-\Delta \mathrm{C}_{1}$ to make the total capacitance correct. With the above switch operation, $\mathrm{V}_{\mathrm{x}}$ would remain zero if $\Delta \mathrm{C}_{1}$ equals zero. However, when $\Delta \mathrm{C}_{1}$ is not zero, the resulting voltage, $\mathrm{V}_{\mathrm{x}}$, is twice the error voltage, defined as $\mathrm{V}_{\mathrm{el}}$, that would be introduced during a normal successive approximation when $\mathrm{C}_{1}$ alone is switched to $\mathrm{V}_{\text {ref }}$. A digital representation
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-061.jpg?height=294&width=510&top_left_y=184&top_left_x=252)

$$
\mathrm{C}_{1}=\left(\frac{\mathrm{C}_{\text {total }}}{2}\right)+\Delta \mathrm{C}_{1}
$$

$$
\mathrm{C}_{2, \mathrm{NB}}=\left(\frac{\mathrm{C}_{\text {total }}}{2}\right)-\Delta \mathrm{C}_{1}
$$

(a)
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-061.jpg?height=514&width=583&top_left_y=195&top_left_x=969)
(b)

Fig. 17.12 Equivalent models for determining capacitance errors. (a) During calibration for $\mathrm{C}_{1}$. (b) During calibration for $\mathrm{C}_{2}$.
of $\mathrm{V}_{\mathrm{el}}$, defined as $\mathrm{DV}_{\mathrm{el}}$, is obtained by doing a successive approximation using the cal-dac shown in Fig. 17.11 and then dividing the resulting digital value by 2 to obtain $\mathrm{DV}_{\mathrm{e} 1}$. This digital correction term, $\mathrm{DV}_{\mathrm{e} 1}$, is stored in the data register for use during regular conversion.

To obtain the similar correction term for $\mathrm{C}_{2}$, defined as $\mathrm{DV}_{\mathrm{e} 2}$, the model in Fig. 17.12(b) is used. Here, the switch procedure is to always leave the $b_{1}$ switch grounded while the comparator is reset, the $b_{2}$ switch is grounded, and the remaining switches $b_{3-N}, s_{N}$ are connected to $V_{\text {ref }}$. Next, the $b_{2}$ and $b_{3-N}, s_{N}$ switches are all reversed (i.e., $b_{2}$ set to $V_{\text {ret }}$ and the others grounded). Note, however, that even if $\Delta C_{2}$ equals zero, the measured value of $V_{x}$ will be equivalent to $-D V_{e 1}$, since $-\Delta C_{1}$ is assumed to be part of $C_{3, \mathrm{NB}}$. Therefore, the error voltage that would be due only to $C_{2}$ can be calculated by digitizing $V_{x}$, as before, but then subtracting off $D V_{e 1}$ using digital circuitry. Mathematically,

$$
\begin{equation*}
D V_{e 2}=\frac{1}{2}\left(D V_{\mathrm{x} 2}-D V_{e 1}\right) \tag{17.29}
\end{equation*}
$$

A similar procedure is used for the other capacitors. Specifically, $\mathrm{DV}_{\mathrm{xi}}$ is found by connecting all capacitors smaller than $C_{i}$ to $V_{\text {ref }}$, and connecting $C_{i}$ and all larger capacitors to ground while the comparator is reset. Next, the comparator is taken out of reset mode, all capacitors smaller than $C_{i}$ are switched to ground, $C_{i}$ is switched to $V_{\text {ref }}$, and all capacitors larger than $C_{i}$ are left connected to ground. $D V_{x i}$ is then found using the cal-dac and successive approximation. $\mathrm{DV}_{\mathrm{ei}}$ is finally calculated using the formula

$$
\begin{equation*}
D V_{e i}=\frac{1}{2}\left(D V_{x i}-\sum_{j=1}^{i-1} D V_{e j}\right) \tag{17.30}
\end{equation*}
$$

and stored in the ${ }_{j}$ th word of the data register.
During a regular conversion, normal successive approximation is performed with the MSB capacitor array; however, appropriate correction voltages are either added or subtracted using the cal-dac and $\mathrm{C}_{\mathrm{NB}}$ capacitor. The proper correction voltage is determined through the use of a digital accumulator that stores the sum of all digital errors of those MSB capacitors deemed to be a 1 (i.e., connected to $V_{\text {ref }}$ ). In other words, when the $i$ th bit is being tested, $\mathrm{DV}_{\text {ei }}$ is added to the digital accumulator that is driving the cal-dac. If the ith bit is determined to be a 0 , then the digital accumulator returns to its previous value; otherwise, it maintains its new accumulated value.

Finally, normal successive approximation is performed using the sub-dac to determine the final LSBs. With this approach, a digital addition must be performed during each bit cycle, and a small amount of digital RAM is required ( 10 bytes in the case of a 10-bit MSB array).

Finally, it should be mentioned that similar error correction techniques have also been described to account for capacitor inaccuracies (for example, [Tan, 1990]).

### 17.2.6 Multi-Bit Successive-Approximation

The successive-approximation converters we have seen so far divide their search space into two on each clock cycle by performing a single comparison. The search can be accelerated by performing multiple comparisons on each clock cycle, and dividing the search space up into smaller regions. For example, if we are trying to guess the value of a random number in the range 1 to 128 , in addition to asking the question "Is the number greater than 64?," imagine that we can simultaneously ask "Is the number greater than 32 ?" and "Is the number greater than 96 ?," With the answers to all three of these questions, we can divide the search space into a quarter: We will know if the number is in the range $1-32,33-64,65-96$, or $97-128$. Hence, we have effectively performed the first two iterations of a binary search. In an analog circuit, this can be done by operating three comparators in parallel. The result is that we require only one-half the number of clock cycles to perform an A/D conversion, hence potentially doubling the converter's sampling rate. However, note that doing so required three comparators (and likely three capacitor banks) instead of only one. A flow graph depicting multi-bit successive-approximation is shown in Fig. 17.13. Naturally, the approach can be extended to perform any number of bits per iteration, but in order to find $L$ bits on each clock cycle, the number of comparisons required $2^{\llcorner }-1$ grows exponentially. Therefore, the number of bits is usually restricted to at most a few.

## 17.3 ALGORITHMIC (OR CYCLIC) A/D CONVERTER

Key Point: Algorithmic converters are similar to successive-approximation converters, except that instead of an accurate D/A converter or capacitor bank, these converters require an accurate gain of two in order to perform the iterative search for a digital code that represents the analog input.

An algorithmic converter operates in much the same way as a succes-sive-approximation converter. However, whereas a successive-approximation converter halves the reference voltage in each cycle, an algorithmic converter doubles the error voltage while leaving the reference voltage unchanged. The flow graph for a signed algorithmic conversion is shown in Fig. 17.14.

### 17.3.1 Ratio-Independent Algorithmic Converter

The block diagram for an algorithmic converter is shown in Fig. 17.15 [McCharles, 1977; Li, 1984]. This converter requires a small amount of analog circuitry because it repeatedly uses the same circuitry to perform its conversion cyclically in time.

One of the difficulties in realizing a high-precision algorithmic converter is building an accurate multiply-by-two gain amp. Fortunately, it is possible to realize the gain amp so that it does not rely on any capacitor matching if four clock cycles are taken for the multiply-by-two operation. The operation of the multiply-by-two gain amp is shown in Fig. 17.16. Although this gain-amp circuitry is shown using single-ended circuits for simplicity, fully differential circuits are normally used.

The basic idea of this gain amp is to sample the input signal twice using the same capacitor. During the second sampling, the charge from the first capacitor is stored on a second capacitor whose size is unimportant. After the second sampling, both charges are recombined into the first capacitor which is then connected between the opamp input and output.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-063.jpg?height=1264&width=1391&top_left_y=181&top_left_x=186)

Fig. 17.13 Flow graph for a 2-bit per iteration successive approximation.

#### EXAMPLE 17.5

Consider the multiply-by-two gain circuitry shown in Fig. 17.16. Assuming the opamp has an input offset designated as $\mathrm{V}_{\text {off }}$, find the values of $\mathrm{V}_{\mathrm{C}_{1}}, \mathrm{~V}_{\mathrm{C}_{2}}$, and $\mathrm{V}_{\text {out }}$ at the end of each of the phases shown.

#### Solution

During phase one, the opamp output, $\mathrm{V}_{\text {out }}$, is connected to the negative opamp input, resulting in

$$
\begin{equation*}
V_{\text {out }}=V_{\text {off }} \tag{17.31}
\end{equation*}
$$

and the voltages across the two capacitors are

$$
\begin{gather*}
\mathrm{V}_{\mathrm{C} 1}=\mathrm{V}_{\mathrm{err}}-\mathrm{V}_{\text {off }}  \tag{17.32}\\
\mathrm{V}_{\mathrm{C} 2}=0-\mathrm{V}_{\text {off }}=-\mathrm{V}_{\text {off }} \tag{17.33}
\end{gather*}
$$

![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-064.jpg?height=1261&width=912&top_left_y=182&top_left_x=444)

Fig. 17.14 Flow graph for the algorithmic and pipelined converter approach.

At the end of phase two, we have

$$
\begin{equation*}
V_{C 1}=0-V_{\text {off }}=-V_{\text {off }} \tag{17.34}
\end{equation*}
$$

implying that its charge change was

$$
\begin{equation*}
\Delta Q_{C 1}=C_{1}\left(V_{\text {err }}-V_{\text {off }}-\left(-V_{\text {off }}\right)\right)=C_{1} V_{\text {err }} \tag{17.35}
\end{equation*}
$$

All this charge is placed on $\mathrm{C}_{2}$, resulting in

$$
\begin{equation*}
\mathrm{V}_{\mathrm{C} 2}=-\mathrm{V}_{\mathrm{off}}+\left(\frac{\mathrm{C}_{1}}{\mathrm{C}_{2}}\right) \mathrm{V}_{\mathrm{err}} \tag{17.36}
\end{equation*}
$$

and $V_{\text {out }}=\left(C_{1} / C_{2}\right) V_{\text {err }}$.
At the end of phase three, $\mathrm{V}_{\mathrm{C} 2}$ remains unchanged since one side of it has been opened. Also, $\mathrm{V}_{\mathrm{C} 1}=\mathrm{V}_{\text {err }}-\mathrm{V}_{\text {off }}$ and $\mathrm{V}_{\text {out }}=\mathrm{V}_{\text {off }}$ as in phase one.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-065.jpg?height=489&width=1144&top_left_y=178&top_left_x=355)

Fig. 17.15 Algorithmic converter.

Finally, at the end of phase four, $\mathrm{C}_{2}$ is discharged to the same value it had in phase 1, resulting in $\mathrm{V}_{\mathrm{C} 2}=-\mathrm{V}_{\text {off }}$ and its change in charge being

$$
\begin{equation*}
\Delta \mathrm{Q}_{\mathrm{C} 2}=\mathrm{C}_{2}\left(\frac{\mathrm{C}_{1}}{\mathrm{C}_{2}}\right) \mathrm{V}_{\mathrm{err}}=\mathrm{C}_{1} \mathrm{~V}_{\mathrm{err}} \tag{17.37}
\end{equation*}
$$

All of this charge is placed back on $C_{1}$, resulting in

$$
\begin{equation*}
\mathrm{V}_{\mathrm{C} 1}=2 \mathrm{~V}_{\mathrm{err}}-\mathrm{V}_{\mathrm{off}} \tag{17.38}
\end{equation*}
$$

and the output voltage being the desired result of $\mathrm{V}_{\text {out }}=2 \mathrm{~V}_{\text {err }}$. Note that this final result is independent of the sizes of $\mathrm{C}_{1}, \mathrm{C}_{2}$, and the offset value, $\mathrm{V}_{\text {off }}$.

## 17.4 PIPELINED A/D CONVERTERS

Pipelined converters, like successive-approximation and algorithmic converters, perform an iterative search for a digital code that accurately reflects the analog input signal. However, rather than perform the iterations with a single analog circuit, pipelined converters have a separate analog stage dedicated to performing each iteration. Signal flow in a pipelined converter is diagrammed in Fig. 17.17. All of the analog stages operate on every clock cycle, each operating on a different input sample. Since N iterations are performed simultaneously, the pipelined converter operates N -times faster than algorithmic converters and is capable of

Key Point: Pipelined $A / D$ converters are similar to algorithmic converters, but employ multiple circuits working on successive input samples simultaneously. Hence, they can complete a conversion on every clock cycle, providing higher throughput than algorithmic converters, but with the same latency.
outputting one conversion on every clock cycle. Therefore, pipelined converters are generally applied when higher speed is desired than is achievable with algorithmic converters. Although N input samples are being processed in parallel, N clock cycles are required for each input sample to proceed through the entire pipeline. Hence, there is a latency of $N$ clock cycles through pipelined converters, just as in algorithmic and successive approximation converters.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-066.jpg?height=330&width=988&top_left_y=196&top_left_x=474)

1. Sample remainder and cancel input-offset voltage.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-066.jpg?height=392&width=985&top_left_y=617&top_left_x=471)
2. Transfer charge $Q_{1}$ from $C_{1}$ to $C_{2}$.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-066.jpg?height=387&width=987&top_left_y=1135&top_left_x=456)
3. Sample input signal with $C_{1}$ again, after storing charge $Q_{1}$ on $C_{2}$.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-066.jpg?height=330&width=990&top_left_y=1632&top_left_x=455)
4. Combine $Q_{1}$ and $Q_{2}$ on $C_{1}$, and connect $C_{1}$ to output.

Fig. 17.16 Multiply-by-two g ain circuitry for an algo rithmic converter that does not depend on capacitor matching.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-067.jpg?height=444&width=1055&top_left_y=180&top_left_x=315)

Fig. 17.17 The signal flow in a pipelined A/D converter.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-067.jpg?height=410&width=1483&top_left_y=777&top_left_x=140)

Fig. 17.18 One-bit pipelined converter stage that accepts inputs in the range $-\mathrm{V}_{\text {ref }} / 2<\mathrm{V}_{\mathrm{i}}<\mathrm{V}_{\text {ref }} / 2$.

### 17.4.1 One-Bit-Per-Stage Pipelined Converter

The operations performed in each stage of a one-bit-per-stage pipelined converter are the same as those for the algorithmic converter shown in Fig. 17.14. Each stage accepts an input from the previous stage, compares it to a reference threshold, and uses a multiplying D/A converter (MDAC) to form a residue signal as follows:

$$
\begin{equation*}
\mathrm{V}_{\mathrm{i}+1}=2\left[\mathrm{~V}_{\mathrm{i}}+\left(\mathrm{b}_{\mathrm{i}}-0.5\right) \mathrm{V}_{\mathrm{ref}} / 2\right] \tag{17.39}
\end{equation*}
$$

The block diagram of a single stage is in Fig. 17.18. It's functionality is very similar to that of the algorithmic converter in Fig. 17.15 except rather than returning the resulting Since a single comparison is performed in each stage, each finds a single bit of the result, $b_{i}$. However, since each stage is operating on a different input sample, these digital bits must be realigned using shift registers of varying lengths, as shown in Fig. 17.19. The result of the conversion may be interpreted as a N -bit quantized estimate of the original input sample within the range $\pm \mathrm{V}_{\text {ref }} / 2$,

$$
\begin{equation*}
\hat{V}_{i n}=V_{\text {ref }} \sum_{i=1}^{N}\left(b_{i}-0.5\right) 2^{-i} \tag{17.40}
\end{equation*}
$$

Finally, note that the final residue signal $\mathrm{V}_{\mathrm{N}+1}$ is not used by any subsequent stage so there is no need to generate it. Hence the final MDAC may be omitted and the last stage is simply a 1-bit $\mathrm{A} / \mathrm{D}$ converter (comparator) generating $b_{N}$.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-068.jpg?height=1024&width=1357&top_left_y=182&top_left_x=212)

Fig. 17.19 A one-bit-per-stage pipelined A/D converter [Martin, 1981].

#### EXAMPLE 17.6

Consider the operation of a 3-bit, one-bit-per-stage pipelined converter with $\mathrm{V}_{\text {ret }}=1 \mathrm{~V}$. Find all of the residue voltages, $\mathrm{V}_{\mathrm{i}}$, and the final output digital code for a sampled input voltage of $\mathrm{V}_{\mathrm{in}}=240 \mathrm{mV}$.

#### Solution

The input signal is given, $\mathrm{V}_{1}=\mathrm{V}_{\mathrm{in}}=240 \mathrm{mV}$. The comparator in the first pipelined stage will output a positive result, $b_{1}=1$. It will, therefore, subtract $V_{\text {ref }} / 4=250 \mathrm{mV}$ from its input and multiply the result by two.

$$
V_{2}=2\left(V_{1}-V_{\text {ref }} / 4\right)=-20 \mathrm{mV}
$$

Since $\mathrm{V}_{2}<0$, in the next clock cycle the comparator of the second pipelined stage will produce a logic low result, $\mathrm{b}_{2}=0$, causing $\mathrm{V}_{\text {ref }} / 4$ to be added for the next residue.

$$
V_{3}=2\left(V_{2}+V_{\text {ref }} / 4\right)=460 \mathrm{mV}
$$

Finally, the third stage will output a high logic level resulting in a final output code of $b_{1} b_{2} b_{3}=101$ equivalent to a quantized input of $\hat{V}_{\text {in }}=187.5 \mathrm{mV}$.

A problem with the one-bit-per-stage pipelined architecture is that any comparator offset results in irreparable errors. In order for a one bit per stage pipelined converter to have $10-\mathrm{mV}$ resolution, the first stage comparator must have better than $10-\mathrm{mV}$ accuracy, the second stage accuracy must be better than 20 mV , the third stage better than 40 mV , and so on. The accuracy requirements diminish as one proceeds along the pipeline since later stages are acting on amplified residue signals, so their impact on the converter's overall accuracy is divided by all of the preceding gain stages when input-referred. Nevertheless, the limitations imposed by comparator offsets mean that the one bit per stage pipeline architecture is rarely used.

#### EXAMPLE 17.7

Repeat Example 17.6, but this time assume that the comparator in the second stage has an offset of 30 mV .

#### Solution

As in Example 17.6, the comparator in the first pipelined stage will output a positive result, $b_{1}=1$, resulting in $\mathrm{V}_{2}=-20 \mathrm{mV}$. This time, however, the second stage comparator offset will cause the second pipelined stage to produce a logic high result, $\mathrm{b}_{2}=1$, causing $\mathrm{V}_{\mathrm{ref}} / 4$ to be subtracted for the next residue.

$$
\mathrm{V}_{3}=2\left(\mathrm{~V}_{2}-\mathrm{V}_{\mathrm{ref}} / 4\right)=-540 \mathrm{~V}
$$

This residue is outside the range $\pm \mathrm{V}_{\text {ref }} / 2$ and therefore results in an excess error in the converter's final result. The final stage will output a logic low resulting in the output code: $\mathrm{b}_{1} \mathrm{~b}_{2} \mathrm{~b}_{3}=110$ or $\mathrm{V}_{\mathrm{in}}=375 \mathrm{mV}$, a less accurate result than the output produced without offset in Example 17.6.

### 17.4.2 1.5 Bit Per Stage Pipelined Converter

Adding a second comparator to each stage of a pipelined converter results in the $1.5-$ bit $^{1}$ stage architecture shown in Fig. 17.20 [Lewis, 1992]. Each stage effectively performs a 3-level quantization of its input,

$$
\begin{equation*}
V_{i, x}=\left(b_{i, 0}-0.5\right) \frac{V_{\text {ref }}}{4}+\left(b_{i, 1}-0.5\right) \frac{V_{\text {ref }}}{4}=\left(b_{i, 0}+b_{i, 1}-1\right) \frac{V_{\text {ref }}}{4} \tag{17.41}
\end{equation*}
$$

This estimate is then subtracted from the input and scaled by $2 \times$ to form the residue $\mathrm{V}_{i+1}$. Equation (17.41) shows that both $b_{i, 0}$ and $b_{i, 1}$ contribute $\pm V_{\text {ref }} / 4$ to the residue and therefore they are weighted equally in determining the converter's digital output. The final stage of is typically a simple two-bit $\mathrm{A} / \mathrm{D}$, since no residue is needed. Assuming the final stage has a two-bit output whose MSB and LSB are $b_{N-1,1}$ and $b_{N-1,0}$ respectively, the final quantized signal is

$$
\begin{equation*}
\hat{V}_{i n}=\frac{V_{\mathrm{ref}}}{2}\left(\sum_{\mathrm{i}=1}^{\mathrm{N}-2}\left(\mathrm{~b}_{\mathrm{i}, 0}+\mathrm{b}_{\mathrm{i}, 1}-1\right) 2^{-\mathrm{i}}+\mathrm{b}_{\mathrm{N}-1,1} 2^{\mathrm{N}-2}+\mathrm{b}_{\mathrm{N}-1,0} 2^{\mathrm{N}-1}\right) \tag{17.42}
\end{equation*}
$$

The output bits of all stages are converted into the final output code by addition with the proper binary weighting, as in (17.42). Of course, prior to addition, the outputs of all stages must be delayed by varying length shift registers to realign the bits in time, as shown in Fig. 17.21.

[^1]![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-070.jpg?height=1040&width=1243&top_left_y=179&top_left_x=271)

Fig. 17.20 A 1.5-bit pipelined converter stage that accepts inputs in the range $-\mathrm{V}_{\text {ref }} / 2<\mathrm{V}_{\mathrm{i}}<\mathrm{V}_{\text {ref }} / 2$. (a) The ideal input-output relationship. (b) The input-output relationship in the presence of comparator offset.

Although the 1.5 bit per stage architecture entails some digital decoding logic, its redundancy makes the converter robust to comparator offsets. The impact of random comparator offsets $\varepsilon_{0}, \varepsilon_{1}$ on the pipeline stage's input-output relationship is shown in Fig. 17.20(b). Intuitively the offsets will, for some input levels, introduce an error of $\pm V_{\text {ref }} / 4$ into $V_{i, x}$ which is reflected in the values of $b_{i, 0}$ and $b_{i, 1}$. They also result in an error of $\mp \mathrm{V}_{\text {ref }} / 2$ in $\mathrm{V}_{\mathrm{i}+1}$, which is captured by the output bits of subsequent stages in the pipeline. When all bits are combined by the decoder (17.42)

Key Point: Introducing redundancy between successive stages in a pipelined converter permits simple digital correction of any offset in the comparators of each stage.
the errors cancel, as long as $\left|\varepsilon_{0,1}\right|<\mathrm{V}_{\text {ref }} / 4$ so that the residue remains within the range $\pm \mathrm{V}_{\text {ref }} / 2$. This argument is inductive; comparator offsets in all 1.5 bit stages are cancelled by subsequent stages. Only offsets in the final stage are left uncanceled. Fortunately, such offsets influence only the converter's 2 LSBs, and are therefore rarely a significant limitation in the design of pipelined converters.

Errors introduced in the MDAC generally limit the performance of pipelined converters. For example, mismatch resulting in errors the DAC voltages $\pm \mathrm{V}_{\text {ref }} / 4$, inaccuracy in the $2 \times$ gain, and thermal noise in the MDAC appear in the residue $V_{i+1}$ but not the comparator outputs $b_{i, 0}$ and $b_{i, 1}$, and are therefore not cancelled. The impact of such errors is greatest at the start of the pipeline, in stage 1 where they influence the converter's most significant bits. Therefore, the first stage is normally designed to be the larger and consume more

Key Point: Pipelined $A / D$ converter performance is limited by nonlinearities and noise in the MDAC, and inaccuracy in the interstage gain, none of which are cancelled by simple digital correction.
power than subsequent stages in order to minimize its mismatch and noise.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-071.jpg?height=1067&width=1466&top_left_y=179&top_left_x=162)

Fig. 17.21 A 1.5-bit-per-stage pipelined A/D converter.

#### EXAMPLE 17.8

Consider the operation of a 3-bit, 1.5-bit-per-stage pipelined converter. Take $\mathrm{V}_{\text {ret }}=1 \mathrm{~V}$ and $\mathrm{V}_{\text {in }}=150 \mathrm{mV}$. Find the residue voltage, $\mathrm{V}_{2}$, the digital codes at the outputs of each stage, and the final digital output after decoding. Then, repeat the exercise assuming the upper comparator of stage 1 has an offset of 30 mV .

#### Solution

In the absence of comparator offset, the digital outputs of stage 1 will be $b_{1,1}=1$ and $b_{1,0}=1$ and the DAC output is $\mathrm{V}_{1, \mathrm{x}}=\mathrm{V}_{\text {ret }} / 4=250 \mathrm{mV}$ and a residue of

$$
\mathrm{V}_{2}=2\left(\mathrm{~V}_{1}-\mathrm{V}_{1 \mathrm{x}}\right)=-200 \mathrm{mV}
$$

This is input to the final stage, a 2-bit $\mathrm{A} / \mathrm{D}$ having a full-scale range of $\pm \mathrm{V}_{\text {ref }} / 2= \pm 500 \mathrm{mV}$. Its binary output is $(01)_{2}$. Hence, the digital code at the output of the decoder is computed as follows:

| $\mathrm{b}_{1,1}:$ | 1 |
| ---: | :---: |
| $\mathrm{~b}_{1,0}:$ | 1 |
| $\mathrm{~b}_{2,1} \mathrm{~b}_{2,0}:$ | 01 |
| $\mathrm{~b}_{1} \mathrm{~b}_{2} \mathrm{~b}_{3}:$ | 101 |

Next, consider what happens if the upper comparator of the first stage has a $30-\mathrm{mV}$ offset, sufficient to cause a error in its output: $\mathrm{b}_{1,1}=0$. As a result, $\mathrm{V}_{1, \mathrm{x}}=0$ and the residue becomes

$$
V_{2}=300 \mathrm{mV}
$$

The binary output of the final-stage 2-bit A/D therefore becomes $(11)_{2}$. The following addition is performed by the decoder:

\begin{aligned} $\mathrm{b}_{1,1}: & 0 \\ \mathrm{~b}_{1,0}: & 1 \\ \mathrm{~b}_{2,1} \mathrm{~b}_{2,0}: & 11 \\$\hline $\mathrm{~b}_{1} \mathrm{~b}_{2} \mathrm{~b}_{3}: & 101\end{aligned}

The error in the first stage is captured by the following stage resulting in the same decoder output as in the ideal case.

### 17.4.3 Pipelined Converter Circuits

Key Point: Switching part of the sampling capacitor into the feedback network provides the interstage gain with a higher feedback factor, and hence higher bandwidth, than a conventional switched-capacitor gain circuit.

The most common implementation of the 1.5 bit stage is shown in Fig. 17.22 [Sutarja, 1988], although fully-differential implementations are used in most high-performance applications. In the first clock phase, the input $\mathrm{V}_{\mathrm{i}}$ is sampled on the total capacitance 2C, Fig. 17.22(a). Then in the second clock phase, Fig. 17.22(b), one-half of the total capacitance is switched to become the feedback capacitance. Reusing the sampling capacitance in this way realizes a gain of 2 with a feedback factor of $\beta=1 / 2$ in Fig. 17.22(b). In a conventional switched-capacitor gain stage, a separate feedback capacitance C is used in addition to the 2 C input sampling capacitance resulting in the lower feedback factor $\beta=1 / 3$ and, hence, lower closed-loop bandwidth and a lower maximum clock frequency.

The other one-half of the sampling capacitance is split into two $\mathrm{C} / 2$ capacitors and reused as a charge redistribution D/A converter during the second clock phase, Fig. 17.22(b). The 1.5 -bit code $b_{i, 1}, b_{i, 0}$ serves as the digital input to the $\mathrm{D} / \mathrm{A}$ and introduces a net change of $\pm \mathrm{V}_{\text {ref }} / 2$ or 0 at the output, $\mathrm{V}_{\mathrm{i}+1}$.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-072.jpg?height=435&width=1444&top_left_y=1547&top_left_x=148)

Fig. 17.22 MDAC for the 1.5 bit per stage pipelined converter during two clock phases: (a) input is sampled onto all capacitors; (b) the input is transferred to the output with a gain of two and the comparator output bits $b_{i, 0}$ and $b_{i, 1}$ determine the subtracted signal.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-073.jpg?height=428&width=1227&top_left_y=183&top_left_x=291)

Fig. 17.23 A general $k$-bit stage in a pipelined A/D converter.

### 17.4.4 Generalized k-Bit-Per-Stage Pipelined Converters

More than one bit can be resolved per stage by increasing the interstage gain and number of comparators per stage. The signal flow is similar to that illustrated in Fig. 17.13 for a 2-bit per iteration successive approximation converter. A generalized k-bit stage is shown in Fig. 17.23. Nonlinearities in the k-bit sub-A/D converter can be digitally corrected by adding additional comparators, similar to the 1.5 bit per stage architecture [Lewis, 1992]. The advantages of the k-bit-per-stage architecture are that fewer stages are needed, which can reduce area and/or power consumption compared with the 1.5 bit per stage. Also, for a given resolution, there are fewer stages for the input signal to traverse through the pipeline, so there are fewer clock cycles of latency in each conversion.

The circuit shown in Fig. 17.22 can be modified to accommodate k bits per stage with $\mathrm{k} \geq 2$ by dividing the input sampling capacitor into smaller unitsized devices. The required interstage gain is greater than 2 , so a smaller fraction of the sampling capacitance is switched into the feedback network in the second clock phase. Hence, the feedback factor $\beta$ is reduced and closed loop bandwidth is decreased compared with the 1.5 -bit stage (assuming the same opamp is used).

The major limitations on converter accuracy remains the accuracy of the inter-

Key Point: Multiple bits can be resolved in each stage, with digital correction, in order to reduce the number of opamps in a pipelined converter and decrease the number of clock cycles required for each conversion.
stage gain, linearity of the sub-D/A converter, and noise in the MDAC circuit. Again, accuracy requirements are most stringent in the first stage where errors influence the most significant bits.

## 17.5 FLASH CONVERTERS

Flash converters are the standard approach for realizing very-high-speed converters. The input signal in a flash converter is fed to $2^{\mathrm{N}}$ comparators in parallel, as shown in Fig. 17.24. Each comparator is also connected to a different node of a resistor string. Any comparator connected to a resistor string node where $\mathrm{V}_{\mathrm{ri}}$ is larger than $\mathrm{V}_{\mathrm{in}}$ will have a 1 output while those connected to nodes with $\mathrm{V}_{\mathrm{ri}}$ less than $\mathrm{V}_{\mathrm{in}}$ will have 0 outputs. Such an output code word is commonly referred to as a thermometer code since it looks quite similar to the mercury bar in a thermometer. Note that the top and bottom resistors in the resistor string have been chosen to create a 0.5 LSB offset in an A/D converter.

Key Point: Flash converters are generally capable of the fastest conversion speeds of any $A / D$ architecture. However, their power consumption grows dramatically with the required resolution so they are usually reserved for converters where high speed and low or modest resolution is sought.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-074.jpg?height=1147&width=1236&top_left_y=182&top_left_x=277)

Fig. 17.24 A 3-bit flash A/D converter.
The NAND gate that has a 0 input connected to its inverting input and a 1 input connected to its noninverting input detects the transition of the comparator outputs from 1 s to 0 s , and will have a 0 output. All other NAND-gate outputs will be 1 , resulting in simpler encoding. It also allows for error detection by checking for more than one 0 output, which occurs during a bubble error (see the next subsection) and, perhaps, error correction.

Flash $\mathrm{A} /$ Ds are fast but the number of comparators grows exponentially with the resolution N , so they typically take up a large area and are very power hungry, even for modest N - especially when they are clocked fast. One way to realize a small clocked CMOS comparator is by using a CMOS inverter, as shown in Fig. 17.25 [Dingwall, 1979].

When $\phi$ is high, the inverter is set to its bistable operating point, where its input voltage equals its output voltage (i.e., its threshold voltage). Normally with an odd number of inverters, a ring oscillator is formed; however, in the case of a single CMOS inverter, the inverter operates as a single stage opamp with only one pole (no nondominant poles), so stability is guaranteed. With this inverter set to its threshold voltage, the other side of C is charged to $\mathrm{V}_{\mathrm{ri}}$. When $\phi$ goes low, the inverter is free to fall either high or low depending on its input voltage. At the same time, the other side of C is pulled to the input voltage, $\mathrm{V}_{\mathrm{in}}$. Since the inverter side of the capacitor is floating, C must keep its original charge, and therefore the inverter's input will change by the voltage difference between $\mathrm{V}_{\mathrm{ri}}$ and $\mathrm{V}_{\mathrm{in}}$. Since the inverter's input was at its bistable point, the difference between $\mathrm{V}_{\mathrm{ri}}$ and $\mathrm{V}_{\mathrm{in}}$ will determine which direction the inverter's output will fall. However, it should be mentioned that this simple comparator suffers from poor power supply rejection, which is often a critical design specification in fast converters. Using fully differential inverters helps alleviate this shortcoming.

### Resistor

string
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-075.jpg?height=303&width=1182&top_left_y=271&top_left_x=345)

Fig. 17.25 A clocked CMOS comparator.

### 17.5.1 Issues in Designing Flash A/D Converters

We discuss here some important design issues that should be addressed when building high-speed flash $A / D$ converters.

Input Capacitive Loading The large number of comparators connected to $\mathrm{V}_{\mathrm{in}}$ results in a large parasitic load at the node $\mathrm{V}_{\mathrm{in}}$. Such a large capacitive load often limits the speed of the flash converter and usually requires a strong and power-hungry buffer to drive $\mathrm{V}_{\mathrm{in}}$. We shall see that this large capacitive loading can be reduced by going to an interpolating architecture.

Resistor-String Bowing Any input currents to the comparators cause errors in the voltages of the nodes of the resistor string. These errors usually necessitate the bias current in the resistor string being two orders of magnitude greater than the input currents of the comparators. This is particularly significant if bipolar comparators are used. The errors are greatest at the center node of the resistor string and thus considerable improvement can be obtained by using additional circuitry to force the center tap voltage to be correct.

Comparator Latch-to-Track Delay Another consideration that is often overlooked is the time it takes a comparator latch to come from latch mode to track mode when a small input signal of the opposite polarity from the previous period is present. This time can be minimized by keeping the time constants of the internal nodes of the latch as small as possible. This is sometimes achieved by keeping the gain of the latches small, perhaps only two to four. In many cases, the differential internal nodes might be shorted together temporarily as a reset just after latch time.

Signal and/or Clock Delay Even very small differences in the arrival of clock or input signals at the different comparators can cause errors. To see this, consider a $250-\mathrm{MHz}, 1-\mathrm{V}$ peak-input sinusoid. This signal has a maximum slope of $1570 \mathrm{~V} / \mu \mathrm{s}$ at the zero crossing. If this signal is being encoded by an 8 -bit $\mathrm{A} / \mathrm{D}$ converter with $\mathrm{V}_{\text {ref }}=2 \mathrm{~V}$ (i.e., the sinusoid covers the whole range), then it would only take 5 ps to change through 1 LSB . This time is roughly about the same time it takes a signal to propagate $500 \mu \mathrm{~m}$ in metal interconnect. If there is clock skew between comparators greater than this, the converter will have more than 1 LSB error. One means of easing this problem is to precede the converter by a sample-and-hold circuit. However, high-speed sample-and-hold circuits can be more difficult to realize than the flash converter itself. In addition, the clock and $\mathrm{V}_{\text {in }}$ should be routed together with the delays matched [Gendai, 1991]. It should also be noted that the delay differences may not be caused just by routing differences, but could also be caused by different capacitive loads, or by phase differences between the comparator preamplifiers at high frequencies.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-076.jpg?height=595&width=1131&top_left_y=182&top_left_x=247)

Fig. 17.26 Using three-input NAND gates to remove single bubble errors.

Substrate and Power-Supply Noise For $\mathrm{V}_{\text {ref }}=1 \mathrm{~V}$ and an 6-bit converter, only 15.6 mV of noise injection would cause a 1 LSB error. On an integrated circuit having a clock signal in the hundreds or even thousands of MHz , it is difficult to keep power-supply noise below 100 mV . This power-supply noise can easily couple through the circuitry or substrate, resulting in errors. To minimize this problem, the clocks must be shielded from the substrate and from analog circuitry. Also, running differential clocks closely together will help prevent the signals from being coupled into the substrate or to critical circuit nodes through the air. Also, analog power supplies should be separated from digital power supplies. Specifically, it is advisable to have analog power supplied to the comparator preamps while using digital power for the latch stages. On-chip power-supply bypass capacitors are a necessity. It is also necessary to make sure the power-supply bypass circuitry doesn't resonate with the circuit packaging parasitics. Small resistors in series with the by-pass capacitors can help dampen any such resonance.

Bubble Error Removal The outputs of the comparators should be a thermometer code with a single transition. However, sometimes a lone 1 will occur within the string of 0 s (or a 0 within the string of 1 s ) due to comparator metastability, noise, cross talk, limited bandwidth, etc. These bubbles usually occur near the transition point of the thermometer code. Fortunately, these bubbles can usually be removed with little extra complexity by replacing the two-input NAND gates shown in Fig. 17.24 with three-input NAND gates, as shown as shown in Fig. 17.26 [Steyaert, 1993]. With this modification, there must now be two 1 s immediately above a 0 in determining the transition point in the thermometer code. However, this circuit will not eliminate the problem of a stray 0 being two places away from the transition point, which may cause a large decoding error. Another digital approach for reducing the effect of bubble errors is to allow bubble errors in the lower 2 LSBs but have the remaining MSBs determined by looking for transitions between every fourth comparator [Gendai, 1991]. With this approach, bubble errors that occur within four places of the transition point do not cause any large errors. An alternate approach to reduce the effect of distant bubble errors is to create two encoders (one AND type and one OR type) rather than a single encoder [Ito, 1994]. When an unexpected output pattern occurs at the NAND outputs, the errors in two different encoders tend to be equal in magnitude but opposite in sign. Thus, the final output is taken as the average of the two encoder outputs, which is performed by adding the two outputs and dropping the LSB (to divide by two).

An alternative method to remove bubble errors that does not increase power dissipation is shown in Fig. 17.27. Here, extra transistors have been added to the inputs of the slave latches, which are driven by the comparator master latches [van Valburg, 1992]. These extra transistors make the value stored in a slave latch not just a function of its master latch, but also a function of the two adjacent master latches. If a bubble occurs, the outputs from the two adjacent master latches are the same, but different from the center master latch. In this case,
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-077.jpg?height=684&width=1278&top_left_y=192&top_left_x=256)

Fig. 17.27 Bubble-error voting circuit that does not increase the power dissipation.
the values from the adjacent master latches overrule the center master latch. Note that with this approach, the power dissipation is not increased because the added transistors make use of existing current in the slave latch. Alternatively, this same voting scheme can be implemented entirely in digital form.

Flashback An additional source of error is flashback. Flashback is caused by clocked comparators, which are almost always used. When clocked comparators are switched from track to latch mode, or vice versa, there is major charge glitch at the inputs to the latch. If there is no preamplifier, this will cause major errors due to the unmatched impedances at the comparator inputs (one input goes to the resistor string-the other to the input signal). To minimize this effect, most modern comparators have one or two stages of continuous-time buffering and/or preamplification. For example, a bipolar comparator is shown in Fig. 17.28. Notice that it has a buffer, a low-gain preamp, and another buffer before the track-and-latch circuitry. Also notice that in the positive feedback latch the feedback is taken from the emitter-follower outputs, which minimizes the capacitances of the internal nodes of the latch. A CMOS comparator may be used with the same topology, although the source-follower buffers are usually omitted.

Another technique sometimes used to minimize the effects of flashback is to match the input impedances as much as is possible. For example, it is possible to implement a second matched resistor string, with the nodes of the comparators that were originally connected to $\mathrm{V}_{\text {in }}$ now being connected to it, and the end nodes of the string connected together to $\mathrm{V}_{\mathrm{in}}$. This approach matches impedances and also minimizes the resistor-string bowing due to the comparator input currents. Unfortunately, it does result in different delays for $\mathrm{V}_{\text {in }}$ reaching the various comparators, and unless these are matched to the routing of the clock signals, these different delays may not be tolerable.

## 17.6 TWO-STEP A/D CONVERTERS

Two-step (or subranging) converters are used for high-speed medium-accuracy A/D converters. They offer several advantages over their flash counterparts. Specifically, two-step converters require less silicon area, dissipate less power, have less capacitive loading, and the voltages the comparators need to resolve are less stringent than for flash equivalents. The throughput of two-step converters approaches that of flash converters, although they do have a larger latency.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-078.jpg?height=775&width=1403&top_left_y=170&top_left_x=184)

Fig. 17.28 Clocked comparator with a preamplifier to reduce flashback.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-078.jpg?height=565&width=1278&top_left_y=1074&top_left_x=240)

Fig. 17.29 An 8-bit two-step A/D converter.

The block diagram for a two-step converter is shown in Fig. 17.29. In fact, a two-step converter may be thought of as a special case of a pipelined converter with only two pipeline stages. The example of Fig. 17.29 shows two 4 bit stages with no redundancy resulting in a 8 -bit output. The 4-bit MSB A/D determines the first four MSBs. To determine the remaining LSBs, the quantization error (residue) is found by reconverting the 4-bit digital signal to an analog value using the 4-bit $\mathrm{D} / \mathrm{A}$ and subtracting that value from the input signal. To ease the requirements in the circuitry for finding the remaining LSBs, the quantization error is first multiplied by 16 using the gain amplifier, and the LSBs are determined using the 4-bit LSB A/D. With this approach, rather than requiring 256 comparators as in an 8-bit flash converter, only 32 comparators are required for a two-step A/D converter. However, this straightforward approach would require all components to be at least 8 -bit accurate. To significantly ease the accuracy requirements of the 4-bit MSB A/D converter, digital error correction is commonly used.

### 17.6.1 Two-Step Converter with Digital Error Correction

The block diagram for a two-step converter with digital error correction is shown in Fig. 17.30. Its operation is directly analogous to that of the 1.5 bit per stage pipeline converter. The ranges of the 4-bit and 5-bit stages overlap, and hence inaccuracies in the first A/D converter can be cancelled by the second. To see how this correction works and why a second-stage 5-bit converter is needed (rather than 4-bit), consider the quantization error that occurs in an ideal converter. Defining $\mathrm{V}_{\mathrm{LSB}}=\mathrm{V}_{\text {ref }} / 2^{8}$ (i.e., always relative to 8-bit accuracy), we have for an ideal 8-bit converter,

Key Point: Two-step converters may be considered a special case of pipelined converters where only 2 pipelined stages are needed. As with pipelined converters, digital error correction greatly relaxes the requirements on the first stage.

$$
\begin{equation*}
\mathrm{V}_{\mathrm{ref}} \mathrm{~B}_{\mathrm{out}}=\mathrm{V}_{\mathrm{in}}+\mathrm{V}_{\mathrm{q}} \quad \text { where } \quad-\frac{1}{2} \mathrm{~V}_{\mathrm{LSB}}<\mathrm{V}_{\mathrm{q}}<\frac{1}{2} \mathrm{~V}_{\mathrm{LSB}} \tag{17.43}
\end{equation*}
$$

However, for a nonideal 8-bit converter with an absolute accuracy of 0.5 LSB , we have

$$
\begin{equation*}
\mathrm{V}_{\text {ref }} \mathrm{B}_{\text {out }}=\mathrm{V}_{\text {in }}+\mathrm{V}_{\mathrm{q}} \quad \text { where } \quad-\mathrm{V}_{\mathrm{LSB}}<\mathrm{V}_{\mathrm{q}}<\mathrm{V}_{\mathrm{LSB}} \tag{17.44}
\end{equation*}
$$

In other words, the maximum quantization signal is now twice that of the ideal case.
Similarly, for an ideal 4-bit A/D converter, we have (keeping the 8-bit definition of $\mathrm{V}_{\mathrm{LSB}}$ ),

$$
\begin{equation*}
\mathrm{V}_{\text {ref }} \mathrm{B}_{\text {out }}=\mathrm{V}_{\text {in }}+\mathrm{V}_{\mathrm{q}} \quad \text { where } \quad-8 \mathrm{~V}_{\mathrm{LSB}}<\mathrm{V}_{\mathrm{q}}<8 \mathrm{~V}_{\mathrm{LSB}} \tag{17.45}
\end{equation*}
$$

Thus in the ideal case, the value of $\mathrm{V}_{\mathrm{q}}$ can be determined (to 8-bit accuracy) using a 4-bit $\mathrm{A} / \mathrm{D}$ converter since $\mathrm{V}_{\mathrm{q}}$ must be within $16 \mathrm{~V}_{\text {LSB }}$. However, for the nonideal case where the 4-bit MSB flash converter has an absolute accuracy of $8 \mathrm{~V}_{\mathrm{LSB}}$, the quantization error, $\mathrm{V}_{\mathrm{q}}$, is now bounded within $32 \mathrm{~V}_{\mathrm{LSB}}$. Thus, in the case of a non-ideal 4-bit MSB converter, a 5-bit LSB converter must be used; otherwise $\mathrm{V}_{\mathrm{q}}$ may go out of range. Note that the gain amplifier of 8 is used to amplify the quantization error back to maximum signal levels to ease the requirements of the 5-bit LSB converter. Finally, to determine $\mathrm{V}_{\mathrm{in}}$, we see that the digital value of $\mathrm{V}_{\mathrm{q}}$ has been found to within
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-079.jpg?height=834&width=1332&top_left_y=1252&top_left_x=229)

Fig. 17.30 An 8-bit two-step A/D converter with digital error correction.
$0.5 \mathrm{~V}_{\text {LSB }}$ and the digital value of $\mathrm{V}_{1}$ is known to the same accuracy since we assumed the $\mathrm{D} / \mathrm{A}$ converter to be 8bit accurate (and the digital word applied to the $\mathrm{D} / \mathrm{A}$ converter is known). Therefore, we find $\mathrm{V}_{\mathrm{in}}$ from the relation

$$
\begin{equation*}
V_{i n}-V_{1}=V_{q} \tag{17.46}
\end{equation*}
$$

Specifically, $\mathrm{V}_{\text {in }}$ is found by properly combining the digital equivalents of $\mathrm{V}_{1}$ and $\mathrm{V}_{\mathrm{q}}$.
In summary, the MSB A/D need only be accurate to $1 / 2^{4}=1 / 16$. The only components that need 0.5 LSB accuracy at the 8 -bit level are S/Hs 1 and 2 , the $\mathrm{D} / \mathrm{A}$, and the subtraction circuit. For a more detailed treatment of a two-step A/D converter, the reader is referred to a 10 -bit 75 MHz implementation (with integrated $\mathrm{S} / \mathrm{H}$ ), described in [Petschacher, 1990].

Besides the difficulty in realizing the $\mathrm{S} / \mathrm{H}$ circuits, another major limitation is the difficulty of designing a high-speed, accurate (to 0.5 LSB at the 5 -bit level) gain amplifier. In fact, due to difficulties in realizing highspeed circuits with gain, often fewer bits are determined in the first stage of a two-step converter to reduce the amplification required. For example, a two-step converter where the first stage resolves only 1 bit is described in [Verbruggen, 2009] achieving very low power.

#### EXAMPLE 17.9

For the two-step 8-bit A/D converter shown in Fig. 17.30, what is the maximum voltage range at $\mathrm{V}_{\mathrm{q}}$ when the converter's full-scale input is $\pm 2.5 \mathrm{~V}$ in the case where the 4 -bit MSB A/D converter is (a) 8 -bit accurate and (b) 4-bit accurate? Assume all other components are ideal.

#### Solution

With a full-scale peak-to-peak input voltage of 5 V applied to an 8 -bit $\mathrm{A} / \mathrm{D}$ converter, we have

$$
\begin{equation*}
\mathrm{V}_{\mathrm{LSB}}=\frac{5}{2^{8}}=19.5 \mathrm{mV} \tag{17.47}
\end{equation*}
$$

For an ideal 4-bit $\mathrm{A} / \mathrm{D}$ converter, we have from (17.45) the maximum voltage range of $\mathrm{V}_{\mathrm{q}}$ is $16 \mathrm{~V}_{\mathrm{LSB}}$, or equivalently, 312 mV .
(a) If we go to the trouble to make the 4-bit $\mathrm{A} / \mathrm{D}$ converter have an absolute accuracy of $0.5 \mathrm{~V}_{\mathrm{LSB}}$ (i.e., 8 -bit accurate), then $\mathrm{V}_{\mathrm{q}}$ becomes bounded between $\pm 8.5 \mathrm{~V}_{\mathrm{LSB}}$. In other words, the maximum range of $\mathrm{V}_{\mathrm{q}}$ would now be $17 \mathrm{~V}_{\mathrm{LSB}}$, or equivalently, 332 mV . Note that the input range of the LSB converter is $8 \times 332 \mathrm{mV}=2.7 \mathrm{~V}$ (a little more than half of the input range of the overall converter), so more gain could be used in this case.
(b) In the case of a 4-bit accurate MSB converter, $\mathrm{V}_{\mathrm{q}}$ is bounded between $\pm 16 \mathrm{~V}_{\mathrm{LSB}}$, implying that the maximum range of $\mathrm{V}_{\mathrm{q}}$ is $32 \mathrm{~V}_{\mathrm{LSB}}$, or equivalently, 618 mV . After the gain of 8 , the input range of the LSB converter becomes $8 \times 618 \mathrm{mV}=4.9 \mathrm{~V}$ (the same as the input range of the overall converter).

## 17.7 INTERPOLATING A/D CONVERTERS

Key Point: The large capacitive input presented by flash A/D converters can be reduced by using fewer input amplifiers and interpolating between them to create the missing intermediate values.

Interpolating converters make use of input amplifiers, as shown in Fig. 17.31. These input amplifiers behave as linear amplifiers near their threshold voltages but are allowed to saturate once their differential inputs become moderately large. As a result, noncritical latches need only determine the sign of the amplifier outputs since the differences between the input signal and threshold voltages have been amplified. Also, the number of input amplifiers attached to $\mathrm{V}_{\mathrm{in}}$ is significantly reduced by interpolating between adjacent outputs of these amplifiers. While this approach is often combined with a "folding" architecture [van de Grift, 1987; van Valburg, 1992], the interpolating architecture has also been used quite successfully by itself [Goodenough, 1989; Steyaert, 1993].
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-081.jpg?height=1192&width=1190&top_left_y=194&top_left_x=307)

Fig. 17.31 A 4-bit interpolating A/D converter (interpolating factor of 4).

To further understand this interpolation approach, some possible signals for the input-amplifier outputs, $\mathrm{V}_{1}$ and $\mathrm{V}_{2}$, as well as their interpolated values are shown in Fig. 17.32. As can be seen in the figure, the logic levels are assumed to be zero and five volts, with the input comparators having a maximum gain of about -10 . Also, here the latch threshold is near the midpoint of the two logic levels (or about 2.5 volts). As $\mathrm{V}_{\mathrm{in}}$ increases, the latch for $V_{1}$ is first triggered, followed by $V_{2 a}$ and so on until $V_{2}$. As a result, more reference levels have been created between $\mathrm{V}_{1}$ and $\mathrm{V}_{2}$. It should be noted here that for good linearity, the interpolated signals need only cross the latch threshold at the correct points, while the rest of the interpolated signals responses are of secondary importance. One way to create such correct crossing points is to ensure that $\mathrm{V}_{1}$ and $\mathrm{V}_{2}$ are linear between their own thresholds. In Fig. 17.32, this linear region corresponds to $0.25<\mathrm{V}_{\text {in }}<0.5$.

For fast operation, it is important that the delays to each of the latches are made to equal each other as much as possible. Since the latch comparators have similar input capacitances associated with them, the delays can be made nearly equal by adding extra series resistors, as shown in Fig. 17.33. These series resistors equalize the impedances seen by each latch comparator looking back into the resistive string, assuming the input-amplifier outputs are low impedance [van de Plassche, 1988].

As mentioned earlier, the main benefit of an interpolating architecture is the reduction in the number of differential pairs attached to the input signal, $\mathrm{V}_{\mathrm{in}}$. Such a reduction results in a lower input capacitance (which is quite
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-082.jpg?height=480&width=978&top_left_y=180&top_left_x=406)

Fig. 17.32 Possible transfer responses for the input-comparator output signals, $\mathrm{V}_{1}$ and $\mathrm{V}_{2}$, and theil interpolated signals.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-082.jpg?height=512&width=707&top_left_y=794&top_left_x=528)

Fig. 17.33 Adding series resistors to equalize delay times to the latch comparators.
high for a flash converter), a slightly reduced power dissipation, and a lower number of accurate reference voltages that need to be created. Finally, it should be mentioned that circuit techniques other than resistive strings can be used to realize this interpolative approach. In [Steyaert, 1993], current mirrors were used to interpolate eight times between comparators. In another implementation, two stages of interpolation using capacitors were realized [Kusumoto, 1993].

### EXAMPLE 17.10

Using current mirrors, show how one can interpolate two current outputs, $I_{1}$ and $I_{2}$, by three. What reduction in input capacitance of the converter would be expected over a traditional flash architecture?

### Solution

If interpolating by three, it is desired to create two new currents, $I_{2 a}, I_{2 b}$ such that

$$
\begin{equation*}
\mathrm{I}_{2 \mathrm{a}}=\frac{2}{3} \mathrm{I}_{1}+\frac{1}{3} \mathrm{I}_{2} \tag{17.48}
\end{equation*}
$$

![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-083.jpg?height=392&width=918&top_left_y=183&top_left_x=441)

Fig. 17.34 Interpolating by three between two current outputs.

$$
\begin{equation*}
I_{2 b}=\frac{1}{3} I_{1}+\frac{2}{3} I_{2} \tag{17.49}
\end{equation*}
$$

These output currents can be realized as shown in Fig. 17.34. These four currents can be converted back to voltages to send to the latches. Alternatively, the currents can be directly sent to latches which make use of current inputs.

Since we are interpolating by three here, this converter would require one-third the number of input amplifiers in relation to a traditional flash converter. Thus, the input capacitance for this interpolated approach would be one-third of that for a flash.

## 17.8 FOLDING A/D CONVERTERS

We just saw that the number of input amplifiers can be reduced through the use of an interpolating architecture. However, the number of latch comparators remains at $2^{\mathrm{N}}$ for an N -bit converter. This large number of latch comparators can be significantly reduced through the use of a folding architecture. A folding A/D converter is similar in operation to a two-step (or subranging) converter in that a group of LSBs are found separately from a group of MSBs. However, whereas a two-step converter requires an accurate D/A converter, a

Key Point: A folding architecture requires fewer latches than a flash converter. It does so similar to a two-step converter, but uses analog preprocessing instead of an accurate D/A converter and gain amplifier.
folding converter determines the LSB set more directly through the use of analog preprocessing while the MSB set is determined at the same time.

As an example, consider the 4 -bit folding converter shown in Fig. 17.35. Defining the folding rate to be the number of output transitions for a single folding block as $\mathrm{V}_{\text {in }}$ is swept over its input range, we see that the folding rate here is four. This folding rate determines how many bits are required in the MSB converter. The operation of this converter is as follows. The MSB converter determines whether the input signal, $\mathrm{V}_{\mathrm{in}}$, is in one of four voltage regions (i.e., between 0 and $1 / 4,1 / 4$ and $1 / 2,1 / 2$ and $3 / 4$, or $3 / 4$ and 1 ). Although the MSB converter is shown separately, these bits are usually determined by combining appropriate signals within the folding blocks. To determine the $2 \mathrm{LSBs}, \mathrm{V}_{1}$ to $\mathrm{V}_{4}$ produce a thermometer code for each of the four MSB regions. Note, however, that the four LSB latches are also used for different MSB regions and the thermometer code is inverted when $\mathrm{V}_{\text {in }}$ is between either $1 / 4$ and $1 / 2$ or $3 / 4$ and 1 . For example, as $\mathrm{V}_{\text {in }}$ increases from 0 to $1 / 4$, the thermometer code changes as $0000,0001,0011,0111,1111$. However, as $\mathrm{V}_{\text {in }}$ continues to increase to $1 / 2$, the code changes as 1110 , $1100,1000,0000$. Also, note that latch comparators can be used for the LSB set since the transitions are amplified by the folding blocks. In summary, folding reduces the number of latch comparators needed as compared to a flash
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-084.jpg?height=1319&width=1451&top_left_y=176&top_left_x=133)

Fig. 17.35 A 4-bit folding A/D converter wit h a folding rate of four. (The MS B converter would usually be realized by combining some folding block signals.)
converter. For example, in a flash 4-bit converter, 16 latches would be required whereas only eight are needed in the 4 -bit folding example of Fig. 17.35. Specifically, four latches are used for the MSB converter and the other four are shown explicitly. In general, the savings can be greater (see Problem 17.29).

The folding blocks can be realized using cross-coupled differential pairs, as seen in the simplified bipolar circuit shown in Fig. 17.36. Here, four sets of differential-pair transistors are connected in such a way as to realize the input-output response shown in Fig. 17.36(b). The output signal $\mathrm{V}_{\text {out }}$ is related to the voltages $\mathrm{V}_{\mathrm{a}}$ and $\mathrm{V}_{\mathrm{b}}$ in an "or" type fashion. In other words, $\mathrm{V}_{\text {out }}$ is low only if both $\mathrm{V}_{\mathrm{a}}$ and $\mathrm{V}_{\mathrm{b}}$ are low; otherwise, $\mathrm{V}_{\text {out }}$ is high. With regard to the behavior of $V_{a}$ and $V_{b}$, note that $V_{b}$ remains low whenever $V_{i n}$ is less than $V_{r 3}$ or greater than $V_{r 4}$. However, $V_{a}$ remains low whenever $V_{i n}$ is greater than $V_{r 2}$ or less than $V_{r 1}$. Also, the cross coupling of adjacent differential pairs causes $V_{a}$ to go high when $V_{i n}$ is between $V_{r 1}$ and $V_{r 2}$, while $V_{b}$ goes high when $V_{\text {in }}$ is between $V_{r 3}$ and $V_{r 4}$. Such behaviors for $V_{a}$ and $V_{b}$ give rise to the folding output for $V_{o u t}$, as shown.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-085.jpg?height=1110&width=1230&top_left_y=178&top_left_x=280)

Fig. 17.36 A folding block with a folding-rate of four. (a) A possible single-ended circuit realization; (b) input-output response.

Some points worth mentioning here are that for full-scale input signals, the output signal from a folding block is at a much higher frequency than the input signal. In fact, the frequency of the folding block's output signal is equal to the multiplication of the frequency of the input signal times the folding rate. This multiplying effect limits the practical folding rate used in high-speed converters. Also, it should be mentioned that the circuit shown is a single-ended version, and differential circuits are almost always used in practical implementations.

Another point to note here is that while the folding approach reduces the number of latch comparators, a large input capacitance similar to that for a flash converter is also present with the folding circuit shown. In fact, flash converters have similar input stages of differential pairs of transistors for each comparator, but they are, of course, not cross coupled. Since the number of differential pairs in each folding block equals the folding rate, and the input signal goes to one side of each differential pair, it can be shown that the number of transistors driven by the input signal equals $2^{\mathrm{N}}$ - the same number as for a flash converter. To reduce this large input capacitance, folding converters also make use of an interpolating architecture. With an interpolate-by-two technique applied to the 4 bit example, the resulting architecture would be that shown in Fig. 17.37. Note that a new inverted signal $\bar{V}_{4}$ is required to connect the top folding block to the bottom one. Although the creation of this inverted signal is needed in a single-ended version, no extra circuitry is required in a differential version since it can be accomplished by simply cross-coupling the differential output wires.

Key Point: Folding is often combined with interpolation so that both the number of latches and the number of input amplifier differential pairs is reduced.

In [van Valburg, 1992], in order to realize a very-high-speed 8-bit converter, four folding blocks each with a folding rate of eight were used. Assuming $V_{\text {ref }}=1 \mathrm{~V}$, then the difference between reference voltages of adjacent inputs of a folding block was $1 / 8 \mathrm{~V}$. Each adjacent folding block was offset by $1 / 32 \mathrm{~V}$, giving zero crossings at each $1 / 32 \mathrm{~V}$. By interpolating between each adjacent folding block using four 8-tap resistor strings, zero crossings every $1 / 256 \mathrm{~V}$ were obtained (i.e., an 8-bit converter with 32 latch comparators connected to the interpolating resistor strings). The MSBs were realized by taking appropriate outputs from selected differential pairs and summing them separately to realize additional folding amplifiers with reduced folding rates. The converter also included circuitry to prevent bubble errors, as shown in Fig. 17.27. Other examples of folding converters are given in [van de Grift, 1987, and Colleran, 1993]. In addition, folding converters have been used in the internal operation of a two-step converter [Vorenkamp, 1992].
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-086.jpg?height=1328&width=1442&top_left_y=731&top_left_x=190)

Fig. 17.37 A 4-bit folding A/D converter with a folding rate of four and an interpolate-by-two. (The MSB converter would usually be realized by combining some folding-block signals.)
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-087.jpg?height=814&width=1262&top_left_y=175&top_left_x=264)

Fig. 17.38 Using the $\mathrm{V}_{1}$ folding block to also determine the top two MSBs.

### EXAMPLE 17.11

In Fig. 17.35, show how the two MSBs can be derived using internal signals from the folding blocks.

### Solution

The MSB, $b_{1}$ is determined by the input signal being above or below $\mathrm{V}_{\text {ret }} / 2$. Looking at Fig. 17.35, we see that the input is compared to the appropriate signal, $(8 / 16) \mathrm{V}_{\text {ref }}$ in the top folding block, producing $\mathrm{V}_{1}$. As a result, the MSB is easily obtained by using the collector current of the transistor connected to $\mathrm{V}_{\mathrm{r} 2}$ in the top folding block. Similarly, the top folding block uses references $4 / 16$ and $12 / 16$, which are needed to determine the second bit, $b_{2}$. In fact, the signal $\mathrm{V}_{1}$ can be used directly as the second bit, $b_{2}$, as seen in Fig. 17.35. Thus, the top two bits, $b_{1}$ and $b_{2}$, can be determined using the top folding block, as shown in Fig. 17.38.

## 17.9 TIME-INTERLEAVED A/D CONVERTERS

Very-high-speed A/D conversions can be realized by operating many A/Ds in parallel [Black, 1980]. The system architecture for a four-channel A/D is shown in Fig. 17.39. Here, $\phi_{0}$ is a clock at four times the rate of $\phi_{1}$ to $\phi_{4}$. Additionally, $\phi_{1}$ to $\phi_{4}$ are delayed with respect to each other by the period of $\phi_{0}$, such that each converter will get successive samples of the input signal, $\mathrm{V}_{\mathrm{in}}$, sampled at the rate of $\phi_{0}$. In this way, the four $A / D$ converters operate at one-quarter the rate of the input sampling frequency.

Key Point: Time-interleaved A/D converters permit high sampling frequency using several lower-rate $A / D$ converters and several phase-shifted clocks.

With this approach, the input $\mathrm{S} / \mathrm{H}$ making use of $\phi_{0}$ is critical, while the remaining four $\mathrm{S} / \mathrm{H}$ converters can have considerable jitter since the signal is already sampled at that point. Thus, sometimes the input $\mathrm{S} / \mathrm{H}$ is realized in a different technology, such as GaAs, while the remaining S/H circuits could be realized in silicon. An example of a 1 GHz 6-bit A/D converter using time interleaving and GaAs S/H circuits is described in [Poulton, 1987], where four bipolar converters operating at 250 MHz were used.

Key Point: A major limitation on the performance of time-interleaved converters is mismatch through the parallel signal paths in either their dc offset, gain, or sampling time. If they can be accurately quantified, sucherrors can be cancelled digitally.

It is also essential that the different $\mathrm{S} / \mathrm{H}$ and $\mathrm{A} / \mathrm{D}$ converter signal paths are extremely well matched, as mismatches will produce tones. For example, consider a m -way time-interleaved converter where one converter has a dc offset of, say, 100 mV . Such a system will produce every m -th digital word different from the other $(m-1)$ and hence tones at $f_{s} / m$ and its harmonics. These tones are independent of the input signal frequency or amplitude, and in fact will be present even if the input is zero. Another source of error arises when the different $\mathrm{S} / \mathrm{H}$ and $\mathrm{A} / \mathrm{D}$ converter circuits present different signal gains. In this case, since the gain is changing periodically, the input signal is effectively being multiplied by a periodic signal. Hence, with a sinusoidal input at $f_{i n}$ the output will contain harmonics at $\mathrm{kf}_{\mathrm{s}} / \mathrm{m} \pm \mathrm{f}_{\mathrm{in}}$ for integers k . Because these are intermodulation products, their frequency and amplitude depends upon the input signal frequency and amplitude. Mismatch between the bandwidth of the parallel signal paths results in frequency-dependent gain mismatch and all of the attendant error tones. Such nonideal behavior can be disastrous for many applications since the tones may reside well within the frequency of interest. A sketch of the output spectrum in the presence of offset and gain mismatches is
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-088.jpg?height=1058&width=1469&top_left_y=1037&top_left_x=133)

Fig. 17.39 A four-channel time-interleaved A/D converter with clock waveforms shown.
presented in Fig. 17.40 with the sources of the various tones identified. Fortunately, if the mismatches between signal paths can be accurately identified they can be cancelled digitally as in Fig. 17.41. Even when cancelled, offset and gain mismatches increase the dynamic range that the constituent $A / D$ converters must be able to handle without nonlinearity.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-089.jpg?height=398&width=1416&top_left_y=399&top_left_x=132)

Fig. 17.40 Spectrum at the output of a 4-way time-interleaved A/D converter with offset and gain mismatches up to the converter's Nyquist frequency, $\mathrm{f}_{\mathrm{s}} / 2$.
![](https://cdn.mathpix.com/cropped/2024_11_07_e169e965a17846596f50g-089.jpg?height=1053&width=1296&top_left_y=1017&top_left_x=247)

Fig. 17.41 A four-channel time-interleaved A/D converter with digital correction for gain and offset mismatch.

## 17.10 KEY POINTS

- Dual-slope integrating conversion proceeds first by integrating the input for a fixed time period, then applying a known input to the integrator and measuring the time required for the integrator output to return to zero. [p. 648]
- Dual-slope conversion does not require accuracy in defining the integration time constant. Offset errors can be calibrated by performing an additional conversion using a known dc input quantity. [p. 648]
- Integrating converters inherently filter the input with a sin $x / x$ frequency response. [p. 649]
- Successive-approximation A/D converters are very versatile, capable of moderately high speed or accuracy with relatively low power. They are relatively simple circuits, in the simplest cases requiring only a single comparator, a bank of capacitors and switches, and a small digital logic circuit. Their biggest drawback is that they operate iteratively and therefore require many clock cycles to perform a single conversion. [p. 652]
- The accuracy of successive-approximation converters is often determined by that of the D/A converter. In the case of charge-redistribution converters, this role is played by a bank of comparators whose matching is important. [p. 653]
- Algorithmic converters are similar to successive-approximation converters, except that instead of an accurate D/A converter or capacitor bank, these converters require an accurate gain of two in order to perform the iterative search for a digital code that represents the analog input. [p. 662]
- Pipelined A/D converters are similar to algorithmic converters, but employ multiple circuits working on successive input samples simultaneously. Hence, they can complete a conversion on every clock cycle, providing higher throughput than algorithmic converters, but with the same latency. [p. 665]
- Introducing redundancy between successive stages in a pipelined converter permits simple digital correction of any offset in the comparators of each stage. [p. 670]
- Pipelined A/D converter performance is limited by nonlinearities and noise in the MDAC, and inaccuracy in the interstage gain, none of which are cancelled by simple digital correction. [p. 670]
- Switching part of the sampling capacitor into the feedback network provides the interstage gain with a higher feedback factor, and hence higher bandwidth, than a conventional switched-capacitor gain circuit. [p. 672]
- Multiple bits can be resolved in each stage, with digital correction, in order to reduce the number of opamps in a pipelined converter and decrease the number of clock cycles required for each conversion. [p. 673]
- Flash converters are generally capable of the fastest conversion speeds of any A/D architecture. However, their power consumption grows dramatically with the required resolution so they are usually reserved for converters where high speed and low or modest resolution is sought. [p. 673]
- Two-step converters may be considered a special case of pipelined converters where only 2 pipelined stages are needed. As with pipelined converters, digital error correction greatly relaxes the requirements on the first stage. [p. 679]
- The large capacitive input presented by flash $\mathrm{A} / \mathrm{D}$ converters can be reduced by using fewer input amplifiers and interpolating between them to create the missing intermediate values. [p. 680]
- A folding architecture requires fewer latches than a flash converter. It does so similar to a two-step converter, but uses analog preprocessing instead of an accurate D/A converter and gain amplifier. [p. 683]
- Folding is often combined with interpolation so that both the number of latches and the number of input amplifier differential pairs is reduced. [p. 686]
- Time-interleaved $\mathrm{A} / \mathrm{D}$ converters permit high sampling frequency using several lower-rate $\mathrm{A} / \mathrm{D}$ converters and several phase-shifted clocks. [p. 687]
- A major limitation on the performance of time-interleaved converters is mismatch through the parallel signal paths in either their dc offset, gain, or sampling time. If they can be accurately quantified, such errors can be cancelled digitally. [p. 688]
